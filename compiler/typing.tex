\section{Typing}


\subsection{Printtyp}
This module mainly export some printting functions for ocaml typed ast.

\begin{ocamlcode}
  val longident: formatter -> Longident.t -> unit
  val ident: formatter -> Ident.t -> unit
  val type_expr: formatter -> Types.type_expr -> unit
  val modtype: formatter -> Types.module_type -> unit
  val signature: formatter -> Types.signature -> unit
  val tree_of_modtype_declaration: Ident.t -> Types.modtype_declaration -> out_sig_item
  val modtype_declaration: Ident.t -> formatter -> Types.modtype_declaration -> unit
  val class_type: formatter -> Types.class_type -> unit
\end{ocamlcode}
\captionof{listing}{Printer in compiler lib \label{compiler-printer}}

You can use this library to process \textit{cmi} files, The structure
of \textit{cmi} file is organized as follows

\begin{ocamlcode}
  let ic = open_in_bin filename in
  let magic_len = String.length (Config.cmi_magic_number) in
  let buffer = String.create magic_len in
  really_input ic buffer 0 magic_len ;
  let (name, (sign:Types.signature)) = input_value ic in
  let (crcs : (string * Digest.t) list) = input_value ic in
  let (flags : flags list) = input_value ic in
  close_in ic ;
\end{ocamlcode}
\captionof{listing}{Structure of cmi file}
\subsection{Types}

This module consists of representation of types and declarations.

\subsection{Typedtree}

This module defines Abstract syntax after typing.
As the code demonstrated below, it decorate type definitions in module
Types .
\begin{ocamlcode}
and module_type =
  { mty_desc: module_type_desc;
    mty_type : Types.module_type;
    mty_env : Env.t; (* BINANNOT ADDED *)
    mty_loc: Location.t }
\end{ocamlcode}


\subsection{Outcometree}

This module defines results displayed by the toplevel These types
represent messages that the toplevel displays as normal results or
errors. The real displaying is customisable using the hooks:

\begin{ocamlcode}
Toploop.print_out_value 
Toploop.print_out_type
Toploop.print_out_sig_item
Toploop.print_out_phrase
\end{ocamlcode}

If you read the source of toplevel, genprint.ml, it maps the
\verb|Types.type_expr| to \verb|Outcometree.out_value|
\begin{ocamlcode}
    val outval_of_value :
          int -> int ->
          (int -> t -> Types.type_expr -> Outcometree.out_value option) ->
          Env.t -> t -> Types.type_expr -> Outcometree.out_value
\end{ocamlcode}


\subsection{Ident}

\subsection{Path}


\begin{ocamlcode}
type t =
    Pident of Ident.t
  | Pdot of t * string * int
  | Papply of t * t
\end{ocamlcode}

\subsection{Btype}
Utilities on core types in module Types

\subsection{Typetexp}
A module which did type checking for the core language.


\subsection{Typecore}
A module which did type inference for the core language.
\begin{ocamlcode}
let reset_delayed_checks () = delayed_checks := []
\end{ocamlcode}
\begin{ocamlcode}
val delayed_checks: (unit -> unit) list ref 
\end{ocamlcode}

\subsection{Cmi\_format}

\begin{ocamlcode}
(* read a cmi from a filename, checking the magic *)
val read_cmi : string -> cmi_infos
\end{ocamlcode}

\subsection{Ctype}

\begin{ocamlcode}
(*
   Type manipulation after type inference
   ======================================
   If one wants to manipulate a type after type inference (for
   instance, during code generation or in the debugger), one must
   first make sure that the type levels are correct, using the
   function [correct_levels]. Then, this type can be correctely
   manipulated by [apply], [expand_head] and [moregeneral].
*)

(*
   General notes
   =============
   - As much sharing as possible should be kept : it makes types
     smaller and better abbreviated.
     When necessary, some sharing can be lost. Types will still be
     printed correctly (+++ TO DO...), and abbreviations defined by a
     class do not depend on sharing thanks to constrained
     abbreviations. (Of course, even if some sharing is lost, typing
     will still be correct.)
   - All nodes of a type have a level : that way, one know whether a
     node need to be duplicated or not when instantiating a type.
   - Levels of a type are decreasing (generic level being considered
     as greatest).
   - The level of a type constructor is superior to the binding
     time of its path.
   - Recursive types without limitation should be handled (even if
     there is still an occur check). This avoid treating specially the
     case for objects, for instance. Furthermore, the occur check
     policy can then be easily changed.
*)

(*
   A faire
   =======
   - Revoir affichage des types.
   - Etendre la portee d'un alias [... as 'a] a tout le type englobant.
   - #-type implementes comme de vraies abreviations.
   - Niveaux plus fins pour les identificateurs :
       Champ [global] renomme en [level];
       Niveau -1 : global
               0 : module toplevel
               1 : module contenu dans module toplevel
              ...
     En fait, incrementer le niveau a chaque fois que l'on rentre dans
     un module.

       3   4 6
        \ / /
       1 2 5
        \|/
         0

     [Subst] doit ecreter les niveaux (pour qu'un variable non
     generalisable dans un module de niveau 2 ne se retrouve pas
     generalisable lorsque l'on l'utilise au niveau 0).

   - Traitement de la trace de l'unification separe de la fonction
     [unify].
*)
\end{ocamlcode}


\subsection{Cmt\_format}


It add binary annots for \verb|cmt_format|.


\begin{ocamlcode}
type binary_annots =
  | Packed of Types.signature * string list
  | Implementation of structure
  | Interface of signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array
and binary_part =
  | Partial_structure of structure
  | Partial_structure_item of structure_item
  | Partial_expression of expression
  | Partial_pattern of pattern
  | Partial_class_expr of class_expr
  | Partial_signature of signature
  | Partial_signature_item of signature_item
  | Partial_module_type of module_type
type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : string option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}
\end{ocamlcode}
\begin{ocamlcode}
    value read_cmt : string -> cmt_infos;
    value read_cmi : string -> Cmi_format.cmi_infos;
    value save_cmt :
      string ->
      string ->
      binary_annots ->
      option string -> Env.t -> option Types.signature -> unit;
\end{ocamlcode}


\subsection{Env}

\begin{ocamlcode}
val find_value: Path.t -> t -> value_description
val find_annot: Path.t -> t -> Annot.ident
val find_type: Path.t -> t -> type_declaration
val find_constructors: Path.t -> t -> constructor_description list
val find_module: Path.t -> t -> module_type
val find_modtype: Path.t -> t -> modtype_declaration
val find_class: Path.t -> t -> class_declaration
val find_cltype: Path.t -> t -> class_type_declaration
\end{ocamlcode}

\begin{ocamlcode}
val lookup_value: Longident.t -> t -> Path.t * value_description
\end{ocamlcode}

\verb|value_descrption| was defined in \verb|Types|


\begin{ocamlcode}
type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind;
    val_loc: Location.t;
   }
\end{ocamlcode}

Notice that \verb|Typedtree| decorate \verb|Types.value_description|
again.
\begin{ocamlcode}
Env.lookup_value (Longident.Lident "f") Toploop.toplevel_env.val;
\end{ocamlcode}

\begin{ocamlcode}
match (Env.lookup_value (Longident.Lident "f") Toploop.toplevel_env.val) with
[ (_,{Types.val_type})  -> Printtyp.type_expr std_formatter val_type ];
\end{ocamlcode}


\begin{ocamlcode}
Env.fold_values 
  (fun s _ _ _ ->
    begin print_string s; print_newline () ; 0 end)
   None (Toploop.toplevel_env.val) 0;
\end{ocamlcode}


\subsection{Includemod}
A module which do inlcusion checks for the module langauge.


\begin{ocamlcode}
val modtypes: Env.t -> module_type -> module_type -> module_coercion
val signatures: Env.t -> signature -> signature -> module_coercion
val compunit: string -> signature -> string -> signature -> module_coercion
val type_declarations:
      Env.t -> Ident.t -> type_declaration -> type_declaration -> unit
\end{ocamlcode}


\subsection{Typemod}
A module consists of type checking for ocaml Ast.
\begin{ocamlcode}
val simplify_signature: signature -> signature
val type_toplevel_phrase:
        Env.t -> Parsetree.structure ->
         Typedtree.structure * Types.signature * Env.t
val simplify_signature:
  Types.signature -> Types.signature
\end{ocamlcode}

\begin{ocamlcode}
value (a,b,c) = 
  let str = s2s <:str_item< value f x = x  >> in
  Typemod.type_toplevel_phrase Env.empty (Obj.magic str) ;
\end{ocamlcode}




\subsection{Predef}

A module consists of predefined type constructors with special typing
rules in typecore.
\subsection{OPrint}
Printer for type definitions in \verb|Outcometree|.

\begin{ocamlcode}
val out_value : (formatter -> Outcometree.out_value -> unit) ref
val out_type : (formatter -> out_type -> unit) ref
val out_class_type : (formatter -> out_class_type -> unit) ref
val out_module_type : (formatter -> out_module_type -> unit) ref
val out_sig_item : (formatter -> out_sig_item -> unit) ref
val out_signature : (formatter -> out_sig_item list -> unit) ref
val out_phrase : (formatter -> out_phrase -> unit) ref
val parenthesized_ident : string -> bool
\end{ocamlcode}
