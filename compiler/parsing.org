#+OPTIONS: ^:{}

** parsing

*** [[file:~/ocaml-svn/parsing/asttypes.mli][parsing/asttypes]]

    It's interesting to note that
    #+BEGIN_SRC ocaml
      type 'a loc = 'a Location.loc = {
        txt : 'a;
        loc : Location.t;
      }
    #+END_SRC

**** Mixing with *Location*
    The initialization is as follows:
    #+BEGIN_SRC ocaml
      let init lexbuf fname =
        lexbuf.lex_curr_p <- {
          pos_fname = fname;
          pos_lnum = 1;
          pos_bol = 0;
          pos_cnum = 0;
        }
      ;;
    #+END_SRC


    #+BEGIN_SRC ocaml
      (** Return an empty ghost range located in a given file. *)
      let in_file name =
        let loc = {
          pos_fname = name;
          pos_lnum = 1;
          pos_bol = 0;
          pos_cnum = -1;
        } in
        { loc_start = loc; loc_end = loc; loc_ghost = true }
      ;;
      
      let none = in_file "_none_";;
    #+END_SRC

*** [[file:~/ocaml-svn/parsing/parsetree.mli][parsing/parsetree]]

    #+BEGIN_SRC ocaml
      Parse.implementation (Lexing.from_string "let a =  M.(b + 3) ");;
    #+END_SRC

    =Clflags.dump_parsetree= in the toplevel can show you the
    parsetree output.

**** syntax categories

***** type-declaration exception-declaration  ;; record type 

       #+BEGIN_SRC ocaml
         and type_declaration = {
           ptype_params: string loc option list;
           (* underscore =>  None, it seems the printer print it back to underscore*)
           ptype_cstrs: (core_type * core_type * Location.t) list;
           ptype_kind: type_kind;
           ptype_private: private_flag;
           ptype_manifest: core_type option;
           ptype_variance: (bool * bool) list;
           ptype_loc: Location.t }
         and type_kind =
           Ptype_abstract
           | Ptype_variant of
               (string loc * core_type list * core_type option * Location.t) list
           | Ptype_record of
               (string loc * mutable_flag * core_type * Location.t) list
         and exception_declaration = core_type list
                  
       #+END_SRC

       #+BEGIN_EXAMPLE
         type-definition ::=     type typedef  { and typedef }  
          
         typedef ::=      [type-params]  typeconstr-name  [type-information]  
          
         type-information        ::=      [type-equation]  [type-representation]  { type-constraint }  
          
         type-equation   ::=     = typexpr  
          
         type-representation     ::=     = constr-decl  { | constr-decl }  
                 ∣        = { field-decl  { ; field-decl } }  
          
         type-params     ::=     type-param  
                 ∣        ( type-param  { , type-param } )  
          
         
         type-param      ::=      [variance] 'ident  
                         |        [variance] _ 
         variance        ::=     +  
                 ∣        -  
          
         constr-decl     ::=     constr-name  
                 ∣       constr-name of  typexpr  { * typexpr }
                 |       constr-name : typexpr {* typexpr} -> typexpr
                 
          
         field-decl      ::=     field-name :  poly-typexpr  
                 ∣        mutable field-name :  poly-typexpr  
          
         type-constraint ::=     constraint ' ident =  typexpr  
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
         exception-definition    ::=     exception constr-name  [of typexpr  { * typexpr }]  
                                 ∣        exception constr-name =  constr
       #+END_EXAMPLE


***** expression
       [[http://www.askra.de/software/ocaml-doc/4.00/expr.html][expression specification]]



       #+BEGIN_EXAMPLE
         argument        ::=     expr  
                 ∣        ~ label-name  
                 ∣        ~ label-name :  expr  
                 ∣        ? label-name  
                 ∣        ? label-name :  expr       
       #+END_EXAMPLE


       #+BEGIN_EXAMPLE
         pattern-matching        ::=      [ | ] pattern  [when expr] ->  expr  { | pattern  [when expr] ->  expr }   ;; (* for function *) when 
          
         multiple-matching       ::=      { parameter }+  [when expr] ->  expr         ;; (* only for fun *) when
       #+END_EXAMPLE


       #+BEGIN_EXAMPLE
         let-binding     ::=     pattern =  expr  
                 ∣        value-name  { parameter }  [: typexpr] =  expr
         
         parameter       ::=     pattern  
                 ∣        ~ label-name  
                 ∣        ~ ( label-name  [: typexpr] )  
                 ∣        ~ label-name :  pattern  
                 ∣        ? label-name  
                 ∣        ? ( label-name  [: typexpr]  [= expr] )  
                 ∣        ? label-name :  pattern  
                 ∣        ? label-name : (  pattern  [: typexpr]  [= expr] )        
       #+END_EXAMPLE
       

***** [[http://www.askra.de/software/ocaml-doc/4.00/types.html][type specification]] Ptyp ;; core-type


       #+BEGIN_EXAMPLE  ;; Ptyp ;; core-type
         
         ;; prefix Ptyp
         typexpr ::=     ' ident                                         ;; var of string 
                 ∣        _                                               ;; any  (**)      
                 ∣        ( typexpr )                                     ;;   
                 ∣        [[?]label-name:]  typexpr ->  typexpr           ;; arrow of label * core_type * core_type (*?x:int -> int *)
                 ∣        typexpr  { * typexpr }+                         ;; tuple of core_type list 
         
                 ∣        typeconstr                                      ;; constr  of Longident.t loc * core_type list
                 ∣        typexpr  typeconstr                             ;; constr  (* singleton list *)
                 
                 ∣        ( typexpr  { , typexpr } )  typeconstr          ;;  constr of Longident.t loc * core_type list
                 ∣        typexpr as '  ident                             ;; alias of core_type * string
                                                                          ;; (* type u = int as 'a  => alias "a" *)   
                 ∣        polymorphic-variant-type                        ;; variant of row_field list * bool * label list option 
                 ∣        < [..] >                                        ;; object of core_field_type list   
                 ∣        < method-type  { ; method-type }  [; ..] >      ;; object ...
                 
                 ∣        # class-path                                    ;;  class of Longident.t loc * core_type list * label list
                                                                         ;; (* type 'a u = (#a as 'a );; *)
                                                                         ;; (* class a = object end;;*)
         
                 ∣        typexpr #  class-path  
         
                 ∣        ( typexpr  { , typexpr } ) #  class-path       ;;  class  "a" [var a] []
                                                                         ;; (* class ['a] a = object val x : 'a list= [] end;; *)     
                                                                         ;; (* type 'a u = ('a #a as 'a) -> int;;*)    
         
                |        (module package-type)                           ;; package of package_type 
         
         package-type := modtype-path                                                       ;; Longident.t loc * (Longident.t loc * core_type) list 
                      | modtype-path with package-constraint {and package-constraint}       ;; ... 
         
         package-constraint := type typeconstr = typexpr 
                      
         poly-typexpr    ::=     typexpr  
                 ∣        { ' ident }+ .  typexpr  
          
         method-type     ::=     method-name :  poly-typexpr
         
         typeconstr      ::=      [ extended-module-path . ]  typeconstr-name
         
         class-path      ::=      [ module-path . ]  class-name
       #+END_EXAMPLE

       In data type definitions, type variables are names for the
       *data type parameters*. In type constraints, they represent
       *unspecified types* that can be instantiated by any type to
       satisfy the type constraint.

******* row-field in Ptyp-variant
        in branch =Ptyp_variant=, it contains =/row_field list *
        bool * label list option/=, the boolean position means it's
        closed or not. for the =row_field=, =Rtag label * bool *
        core_type list= corresponds something like =/`a of int *
        bool/=, In the =row_field=, the =core_type list= means it's an
        *intersection* of list of types.  The =label list= is the
        lower bound, it is Some only when it's non-exact closed
        variant type.

        In all three cases, tags may be either specified directly in
        the =/`tag-name [of typexpr]/= form, or indirectly through a type
        expression. In this last case, the type expression must expand
        to an exact variant type, whose tag specifications are
        inserted in its place.

        Full specifications of variant tags are *only* used for
        *non-exact* closed types. They can be understood as a
        *conjunctive type* for the argument: it is intended to have all
        the types enumerated in the specification.

        Such conjunctive constraints may be unsatisfiable. In such a
        case the corresponding tag may not be used in a value of this
        type. This does not mean that the whole type is not valid: one
        can still use other available tags.

        =/Rinherit/= is simply a type abbreviation.

        #+BEGIN_SRC ocaml
          type 'a u = 'a constraint 'a = [< `a | `b | `c > `c ]
                                           
          Ptyp_variant closed=true
            [
              Rtag "a" true
              []
              Rtag "b" true
              []
              Rtag "c" true
              []
            ]
            Some
            [
              "c"
            ]
          
        #+END_SRC


        #+BEGIN_SRC ocaml
          type 'a ab = [< `a|`b] as 'a ;;
          type 'a ac = 'a constraint 'a = [< `a | `c ]
          type ('a,'b) m = [< `m of 'a ab & 'a ac ] as 'b;;
          
          (*  
            Ptyp_variant closed=true
            [
              Rtag "m" false
                   [
                     core_type 
                       Ptyp_constr "ab"
                       [
                         core_type 
                           Ptyp_var a
                       ]
                       core_type 
                       Ptyp_constr "ac"
                       [
                         core_type 
                           Ptyp_var a
                       ]
                   ]
            ]
            Some
            []
           *)
          let u : ('a,'b) m = `m `a;;
          val u : ([ `a ], [ `m of [ `a ] ab ]) m = `m `a
        #+END_SRC

******* core-field-desc in Ptyp-object 
        it's straight-forward, when you have a row-variable, in the
        last field you have a =/Pfield_var/=

        #+BEGIN_SRC ocaml
          type 'a u = 'a constraint 'a = < draw : int; .. >
          
          Ptyp_object
            [
              core_field_type 
                Pfield "draw"
                core_type 
                Ptyp_poly
                core_type 
                Ptyp_constr "int"
                []
                core_field_type 
                Pfield_var
            ]
                                                         
        #+END_SRC
        

***** [[http://www.askra.de/software/ocaml-doc/4.00/patterns.html][Pattern]] Ppat  ;; pattern-desc
       
       #+BEGIN_EXAMPLE  ;; Ppat
         
         ;; prefix Ppat
         pattern ::=     value-name                                           ;;  var of string loc 
                 ∣        _                                                   ;; any 
                 ∣        constant                                            ;; constant of constant
                 ∣        pattern as  value-name                              ;; alias of pattern * string loc   
                 ∣        ( pattern )  
                 ∣        ( pattern :  typexpr )                              ;; constraint of pattern * core_type
                 ∣        pattern |  pattern                                  ;; or of pattern * pattern 
                 ∣        constr  pattern                                     ;; construct of Longident.t loc * pattern option * bool
                                                                              ;; follows tuple or None 
                                                                              
                 ∣        `tag-name  pattern                                  ;; variant of label * pattern option
                                                                              ;;
                                                                              
                 ∣        #typeconstr-name                                    ;; type of Longident.t loc
                 ∣        pattern  { , pattern }                              ;; tuple of pattern list   
                 ∣        { field =  pattern  { ; field =  pattern }  [ ; ] } ;; record of Longident.t loc * pattern option * bool
                 |       {field = [=pattern] {; field[=pattern]} [; _]}       ;; record of ...
                                                                              ;; the pattern was computed during parsing time to be var   
                 ∣        [ pattern  { ; pattern }  [ ; ] ]                   ;; construct of Longident.t loc * pattern option * bool 
                 ∣        pattern ::  pattern                                 ;; construct of Longident.t loc * pattern option * bool (* list is not special*)
                 ∣        [| pattern  { ; pattern }  [ ; ] |]                 ;; array of pattern list 
                 ∣        lazy pattern                                        ;; lazy of pattern
                 |        (module module-name[:package-type])                ;; unpack of string loc
                                                                            ;; it will be translated into (constraint (unpack "U") , (package "S")) 
         
       #+END_EXAMPLE

       Range patterns =/'a' .. 'z'/= will be expanded during parsing
       time to =/or (constant 95) blabla/=


***** expr ;; Pexp
       #+BEGIN_EXAMPLE ;; Pexp
         
         ;; prefix Pexp 
         expr    ::=     value-path  
                 ∣        constant                                                          ;; constant of constant
                 ∣        ( expr )                                                          ;;   
                 ∣        begin expr end                                                    ;; sequence of expression * expression 
                 ∣        ( expr :  typexpr )                                               ;; constraint of expression * core_type option * core_type option (* x:int :> int*)
                 ∣        expr  {, expr}+                                                   ;; tuple of  expression list 
                 ∣        constr  expr                                                      ;; construct of Longident.t loc * expression option * bool
                                                                                           ;; follows a tuple
                                                                                           ;; you can not discriminate  tuple here... it's a flaw, it's discriminable in Ptyp however
                 ∣        `tag-name  expr                                                   ;; variant of label * expression option  
                 ∣        expr ::  expr                                                     ;; construct of 
                 ∣        [ expr  { ; expr }  [;] ]                                         ;; construct
                 ∣        [| expr  { ; expr }  [;] |]                                       ;; array of expression list 
                 ∣        { field =  expr  { ; field =  expr }  [;] }                       ;; record of (Longident.t loc * expression) list * expression option (* a with f = 3*)  
                 |        { field [=expr] {; field [=expr]}}                               ;; record of ...
                 ∣        { expr with  field =  expr  { ; field =  expr }  [;] }            ;; record of ...
                 |        { expr with field [=expr] {;field [= expr]}}                     ;; record
                                                                                           ;; computation done at parsing time 
                 ∣        expr  { argument }+                                               ;; apply of expression *  (label * expression) list
                                                                                           ;; f ~g
                                                                                           ;; f ~g:g
                                                                                           
                 ∣        prefix-symbol  expr                                               ;; apply of ... 
                 ∣        expr  infix-op  expr                                              ;; apply of ...
                 ∣        expr .  field                                                     ;; field of expression * Longident.loc  
                 ∣        expr .  field <-  expr                                            ;; setfield of expression * Longident.t loc * expression 
         
                 ∣        expr .(  expr )                                                   ;; apply .. Array.get
                 ∣        expr .(  expr ) <-  expr                                          ;; apply .. Array.set
                 ∣        expr .[  expr ]                                                   ;; apply .. String.get
                 ∣        expr .[  expr ] <-  expr                                          ;; apply .. String.set   
                 ∣        if expr then  expr  [ else expr ]                                 ;; ifthenelse of expression * expression * expression option 
                 ∣        while expr do  expr done                                          ;; while of expression * expression 
                 ∣        for ident =  expr  ( to ∣  downto ) expr do  expr done            ;; for of string loc * expression * expression * direction_flag * expression 
                 ∣        expr ;  expr                                                      ;; sequence of expression * expression 
                 ∣        match expr with  pattern-matching                                 ;; match of expression * (pattern * expression ) list
                 ∣        function pattern-matching                                         ;; function of label * expression option * (pattern*expression) list
                                                                                           ;;  (* let f ?y:3 = y *) => function of "?y" (Some 3) [var "y"; "y"]
                                                                                           ;; in this case, the list will be a singleton list
                 
                 ∣        fun multiple-matching                                             ;; function ...
                 ∣        try expr with  pattern-matching                                   ;; try of expression * (pattern * expression) list
                 ∣        let [rec] let-binding   { and let-binding } in  expr              ;; let of rec_flag * (pattern * expression ) list * expression 
                 ∣        new class-path                                                    ;; new of Longident.t loc    
                 ∣        object class-body end                                             ;; object of class_structure   
                 ∣        expr #  method-name                                               ;; send of expression * string 
         
                 ∣        inst-var-name                                                     ;; ident   
         
                 ∣        inst-var-name <-  expr                                            ;; setinstvar of string loc * expression
                                                                                           ;;     (* method p = x <- 4 *)
            
                 ∣        ( expr :>  typexpr )                                              ;; constraint ..
                 ∣        ( expr :  typexpr :>  typexpr )                                   ;; constraint ..
                 
                 ∣        {< inst-var-name =  expr  { ; inst-var-name =  expr }  [;] >}     ;; override of (string loc * expression) list
                                                                                           ;; (* method a = {< x = 4 >}*)
                                                                                           ;; poly of expression * core_type option
                                                                                           
                 ∣        assert expr                                                      ;; assert of expression
                 |       assert false                                                      ;; assertfalse
                 ∣        lazy expr                                                        ;; lazy of expression 
         
                 |       let module module-name = module-expr in expr                      ;; letmodule  of string loc * module_expr * expression
         
                 |       let open module-path in expr                                      ;; open of Longident.t loc * expression
                 |       module-path.( expr )                                              ;; open of Longident.t loc * expression
         
                 |       (module module-expr [:package-type])                              ;; pack of module_expr
                                                                                           ;; constraint of expression * core_type option * core_type option
                 |      
       #+END_EXAMPLE
***** let-binding

      #+BEGIN_EXAMPLE
        let-binding     ::=     pattern =  expr  
                        ∣        value-name  { parameter }  [: typexpr] =  expr
                        ∣        value-name :  poly-typexpr =  expr
                        |       value-name : type {typeconstr}  . typexpr = expr
      #+END_EXAMPLE

      Polymorphic type annotations in let-definitions behave in a way
      similar to polymorphic methods: they explicitly require the
      defined value to be polymorphic, and allow one to use this
      polymorphism in recursive occurences (when using let rec). Note
      however that this is just an usual polymorphic type, unifiable
      with any instance of itself.


      The =(type t)= syntax construction by itself does not make
      polymorphic the type variable it introduces, but it can be
      combined with explicit polymorphic annotations where
      needed. Some syntactic sugar is provided to make this
      easier. Namely,

      #+BEGIN_SRC ocaml
        let rec f : type t1 t2. t1 * t2 list -> t1 = ...      
      #+END_SRC

      is automatically expanded into

      #+BEGIN_SRC ocaml
        let rec f : 't1 't2. 't1 * 't2 list -> 't1 =
          fun (type t1) (type t2) -> (... : t1 * t2 list -> t1)
      #+END_SRC

      The translation is done at *parsing time*

      #+BEGIN_SRC ocaml
        let f : type t . t list  = [];;
        (*
        Ptop_def
          [
            structure_item (//toplevel//[93,2+-2]..//toplevel//[93,2+27])
              Pstr_value Nonrec
              [
                <def>
                  pattern (//toplevel//[93,2+2]..//toplevel//[93,2+27]) ghost
                    Ppat_constraint            pattern (//toplevel//[93,2+2]..//toplevel//[93,2+3])
                      Ppat_var "f"
                    core_type (//toplevel//[93,2+2]..//toplevel//[93,2+27]) ghost
                      Ptyp_poly 't
                      core_type (//toplevel//[93,2+15]..//toplevel//[93,2+21])
                        Ptyp_constr "list"
                        [
                          core_type (//toplevel//[93,2+15]..//toplevel//[93,2+16])
                            Ptyp_var t
                        ]
                  expression (//toplevel//[93,2+2]..//toplevel//[93,2+27])
                    Pexp_newtype "t"
                    expression (//toplevel//[93,2+2]..//toplevel//[93,2+27])
                      Pexp_constraint
                      expression (//toplevel//[93,2+25]..//toplevel//[93,2+27])
                        Pexp_construct "[]"
                        None
                        false
                      Some
                        core_type (//toplevel//[93,2+15]..//toplevel//[93,2+21])
                          Ptyp_constr "list"
                          [
                            core_type (//toplevel//[93,2+15]..//toplevel//[93,2+16])
                              Ptyp_constr "t"
                              []
                          ]
                      None
              ]
          ]
         *)  
      #+END_SRC


***** parameter

      #+BEGIN_EXAMPLE
        parameter       ::=     pattern  
                ∣        ~ label-name  
                ∣        ~ ( label-name  [: typexpr] )  
                ∣        ~ label-name :  pattern  
                ∣        ? label-name  
                ∣        ? ( label-name  [: typexpr]  [= expr] )  
                ∣        ? label-name :  pattern  
                ∣        ? label-name : (  pattern  [: typexpr]  [= expr] )
                ∣        ( type typeconstr-name )                                       ;; Pexp_newtype of string * expression
                                                                                       ;; string and expression in its scope 
      #+END_EXAMPLE

      The expression fun ( type typeconstr-name ) -> expr introduces a
      type constructor named typeconstr-name which is considered
      abstract in the scope of the sub-expression, but then replaced
      by a fresh type variable.

      This construction is useful because the type constructor it
      introduces can be used in places where a *type variable* is not
      allowed. For instance, one can use it to define an exception in
      a local module within a polymorphic function.


***** signature-item Psig 
       #+BEGIN_EXAMPLE ;; signature-item Psig
         ;; prefix Psig
         
         
         specification   ::=     val value-name :  typexpr                                               ;; value of string loc * value_description 
                 ∣        external value-name :  typexpr =  external-declaration                         ;; value of string loc * value_description   
                 ∣        type-definition                                                                ;; type of (string loc * type_declaration ) list 
                 ∣        exception constr-decl                                                          ;; exception of string loc * exception_declaration        
                 ∣        class-specification                                                            ;; class of class_description list    
                 ∣        classtype-definition                                                           ;; class_type of class_type_declaration list    
                 ∣        module module-name :  module-type                                              ;; module of string loc * module_type 
                 ∣        module module-name  { ( module-name :  module-type ) } :  module-type          ;; module of string loc * module_type ...
                 ∣        module type modtype-name                                                       ;; modtype of string loc * modtype_declaration    
                 ∣        module type modtype-name =  module-type                                        ;; modtype of string loc * modtype_declaration   
                 ∣        open module-path                                                               ;; open of Longident.t loc    
                 ∣        include module-type                                                            ;; include of module_type    
                 |        module rec module-name: module-type {and module-name:module-type}              ;; recmodule of (string loc * module_type)list
       #+END_EXAMPLE
******* modtype-declaration Pmodtype

        #+BEGIN_SRC ocaml
          and modtype_declaration =
              Pmodtype_abstract
            | Pmodtype_manifest of module_type
                  
        #+END_SRC


***** module-type ;; Pmty
       #+BEGIN_EXAMPLE ;; module-type Pmty
         ;; prefix  Pmty
         
         
         module-type     ::=     modtype-path                                                            ;; ident of Longident.t loc 
                 ∣        sig { specification  [;;] } end                                                ;; signature of signature
                 ∣        functor ( module-name :  module-type ) ->  module-type                         ;; functor of string loc * module_type * module_type
                 ∣        module-type with  mod-constraint  { and mod-constraint }                       ;; with of module_type * (Longident.t loc * with_constraint) list   
                 ∣        ( module-type )                                                                ;; ...
                 |        module type of module-expr                                                     ;; typeof of module_expr
         
       #+END_EXAMPLE
     #+BEGIN_SRC ocaml
       module type U = module type of struct let v = 3 end;;
     #+END_SRC
******* with-constraint

        #+BEGIN_EXAMPLE
          ;; prefix Pwith        
          mod-constraint  ::=     type [type-params]  typeconstr =  typexpr                                                        ;; type of type_declaration 
                          ∣        module module-path =  extended-module-path                                                      ;; module of Longident.t loc
                          ∣        type [type-parameters]  typeconstr-name :=  [type-parameters]  typeconstr                       ;; typesubst of type_declaration 
                          ∣        module module-name :=  extended-module-path                                                     ;; modsubst of Longiden.t loc 
                   
          
                  
        #+END_EXAMPLE


***** module-expr Pmod

       #+BEGIN_EXAMPLE ;; module-expr Pmod
         
         
         module-expr     ::=     module-path                                                     ;; ident of Longident.t loc
                 ∣        struct { definition  [;;] ∣  expr ;; } end                              ;; structure of structure   
                 ∣        functor ( module-name :  module-type ) ->  module-expr                 ;; functor of string loc * module_type * module_expr
                 ∣        module-expr (  module-expr )                                           ;; apply of module_expr * module_expr
                 ∣        ( module-expr )                                                        ;; ...   
                 ∣        ( module-expr :  module-type )                                         ;; constraint of module_expr * module_type
         
                 |       (val expr [:package-type])                                             ;;  unpack of expression
                                                                                                ;; under constraint, compiler can infer optional           
       #+END_EXAMPLE


***** structure-item Pstr
       #+BEGIN_EXAMPLE ;; structure-item Pstr
         
         ;; prefix Pstr
         definition      ::=     let [rec] let-binding   { and let-binding }                                             ;; vlaue of rec_flag * (pattern * exprssion ) list 
                 ∣        external value-name :  typexpr =  external-declaration                                          ;; primitive of string loc * value_description   
                 ∣        type-definition                                                                                 ;; type of (string loc * type_declaration ) list   
                 ∣        exception-definition                                                                            ;; exception of string loc * exception _declaration    
                 ∣        class-definition                                                                                ;; class of class_declaration list               
                 ∣        classtype-definition                                                                            ;; class_type of class_type_declaration list 
                 ∣        module module-name  { ( module-name :  module-type ) }  [ : module-type ]  =  module-expr       ;; module of string loc * module_expr 
                 ∣        module type modtype-name =  module-type                                                         ;; modtype of string loc * module_type    
                 ∣        open module-path                                                                                ;; open of Longident.t loc    
                 ∣        include module-expr                                                                             ;; include of module_expr
         
                 |        module rec module-name: module-type = module-expr {and module-name: module-type = module-expr} ;; recmodule of (string loc * module_type * module_expr) list
       #+END_EXAMPLE


***** toplevel directive

       #+BEGIN_SRC ocaml
         type toplevel_phrase =
             Ptop_def of structure
           | Ptop_dir of string * directive_argument
         and directive_argument =
             Pdir_none
           | Pdir_string of string
           | Pdir_int of int
           | Pdir_ident of Longident.t
           | Pdir_bool of bool
       #+END_SRC

***** class-expr  ;; Pcl 
       #+BEGIN_EXAMPLE ;; class-expr  Pcl
         ;; prefix Pcl class language
         class-expr      ::=     class-path                                                      ;; constr ...
                 ∣         [ typexpr  {, typexpr} ]  class-path                                  ;; constr of Longident.t loc * core_type list
                 ∣         ( class-expr )                                                        ;; ...
                 ∣         ( class-expr :  class-type )                                          ;; constraint of class_expr * class_type         
                 ∣         class-expr  {argument}+                                               ;; apply of class_expr * (label * expresson) list
                 ∣         fun {parameter}+ ->  class-expr                                       ;; fun of label * expression option * patern * class_expr 
                 ∣         let [rec] let-binding  {and let-binding} in  class-expr               ;; let of rec_flag * (pattern * expression) list * class_expr 
                 ∣         object class-body end                                                 ;; cl_structure of class_structure
         
       #+END_EXAMPLE


***** class-field ;; Pcf
       #+BEGIN_EXAMPLE ;; class-field Pcf
         ;; prefix Pcf
         
         class-field     ::=     inherit[!] class-expr  [as value-name]                             ;; inher of override_flag * class_expr * string option 
                 ∣         val[!] [mutable] inst-var-name  [: typexpr] =  expr                      ;; val of string loc * mutable_flag * override_flag * expression 
                 ∣         val [mutable] virtual inst-var-name :  typexpr                        ;; valvirt of string loc * mutable_flag * core_type
         
                 ∣         method[!] [private] method-name  {parameter}  [: typexpr] =  expr        ;; meth of string loc * private_flag * override_flag * expression 
                 ∣         method[!] [private] method-name :  poly-typexpr =  expr                  ;; meth ... Pexp_poly of expression * core_type option 
                 ∣         method [private] virtual method-name :  poly-typexpr                  ;; virt of string loc * private_flag * core_type 
                 ∣         constraint typexpr =  typexpr                                         ;; constr of core_type * core_type            
                 ∣         initializer expr                                                      ;; init of expression    
         
       #+END_EXAMPLE


***** class-type ;; Pcty
       #+BEGIN_EXAMPLE ;; class-type Pcty
         
         ;; prefix Pcty                  
         class-type      ::=     class-body-type                                                 ;;  see below
                 ∣         [[?]label-name:]  typexpr ->  class-type                              ;; fun of label * core_type * class_type         
          
         class-body-type ::=     object [( typexpr )]  {class-field-spec} end                    ;; signature of class_signature
                 ∣         class-path                                                            ;; constr of Longident.t loc * core_type list
                 ∣         [ typexpr  {, typexpr} ]  class-path                                  ;; constr ...   
       #+END_EXAMPLE


***** class-type-field
       #+BEGIN_EXAMPLE ;; class-type-field Pctf 
         
         ;; prefix Pctf
         class-field-spec        ::=     inherit class-type                                              ;; inher of class_type
                 ∣         val [mutable] [virtual] inst-var-name :  typexpr                              ;; val of string * mutable_flag * virtual_flag * core_type    
                 ∣         method [private] method-name :  poly-typexpr                                  ;; meth of string * private_flag * core_type
                 ∣         method [private] virtual method-name :  poly-typexpr                          ;; virt  of string * private_flag * core_type
                 ∣         constraint typexpr =  typexpr                                                 ;; cstr of core_type * core_type   
       #+END_EXAMPLE
       
       



       

*** [[file:~/ocaml-svn/parsing/parser.mly][parsing/parser.mly]]

    There's some special treatment for option type
**** grammrs
***** entry points
      #+BEGIN_SRC ocaml
        implementation: structure EOF ; {$1}
        interface: signature EOF; {List.rev $1}
        
        toplevel_phrase:
        top_structure SEMISEMI {Ptop_def $1}
        | seq_expr SEMISEMI {Ptop_def [ghstrexp $1]}
        | toplevel_directive SEMISEMI {$1}
        | EOF {raise End_of_file};
        
        top_structure:
        structure_item {[$1]}
        | structure_item top_structure {$1 ::$2};               
        
        use_file:
        use_file_tail {$1}
        | seq_expr use_faile_tail {Ptop_def [ghstrexp $1] :: $2};
        
        use_file_tail:
        EOF {[]}
        | SEMISEMI EOF {[]}
        | SEMISEMI seq_expr use_file_tail {Ptop_def [ghstrexp $2] :: $3}
        | SEMISEMI structure_item use_file_tail {Ptop_def[$2] :: $3}
        | SEMISEMI toplevel_directive use_file_tail {$2::$3}
        | structure_item use_file_tail {Ptop_def[$1]::$2}
        | toplevel_directive use_file_tail {$1 ::$2};
      #+END_SRC
***** module expressions
      #+BEGIN_SRC ocaml
        module_expr:
        | mod_longident      {mkmod(Pmod_ident (mkrhs $1 1))}
        | STRUCT structure END {mkmod (Pmod_structure($2))}
        | STRUCT structure error {unclosed "struct" 1 "end" 3}
        | FUNCTOR LPAREN UIDENT COlON module_type PAREN MINUSGREATER module_expr
                  {mkmod (Pmod_functor (mkrhs $3 3, $5, $8 ))}
        | module_expr LPAREN module_expr RPAREN {mkmod(Pmod_apply($1,$3))}
        | module_expr LPAREN module_expr error {unclosed "(" 2 ")" 4 }
        | LPAREN module_expr COLON module_type PAREN
                 {mkmod (Pmod_constraint($2,$4))}
        | LPAREN module_expr COLON module_type error
                 {unclosed "(" 1 ")" 5}
        | LPAREN module_expr RPAREN {$2}
        | LPAREN module_expr error {unclosed "(" 1 ")" 3}
        
        | LPAREN VAL expr RPAREN {mkmod (Pmod_unpack $3)}
        | LPAREN VAL expr COLON package_type RPAREN
           {mkmod
              (Pmod_unpack(ghexp(Pexp_constraint($3, Some(ghtyp(Ptyp_package $5)), None))))}
        (* :> *)
        | LPAREN VAL expr COLON package_type COLONGREATER package_type PAREN
           {mkmod
              (Pmod_unpack(ghexp(Pexp_constraint($3, Some(ghtyp(Ptyp_package $5)),
                                                 Some(ghtyp(Ptyp_package $7))))))
           }
        | LPAREN VAL expr COLONGREATER package_type RPAREN
           { mkmod(Pmod_unpack(ghexp(Pexp_constraint($3,None,Some(ghtyp(Ptyp_package $5))))))}
        
        | LPAREN VAL expr COLON error {unclosed "(" 1 ")" 5}
        | LPAREN VAL expr error {unclosed "(" 1 ")" 4 };
      #+END_SRC
      
***** structure
      #+BEGIN_SRC ocaml
        structure:
          structure_tail {$1}
        | seq_expr structure_tail {ghstrexp $1 :: $2};
        structure_tail:
          /* empty */ {[]}
        | SEMISEMI {[]}
        | SEMISEMI  seq_expr structure_tail {ghstrexp $2 :: $3}
        | SEMISEMI structure_item structure_tail {$2 :: $3}
        | structure_item structure_tail {$1::$2};
        
        structure_item:
          LET rec_flag let_bindings
              {match $3 with
                 [{ppat_desc=Ppat_any; ppat_loc=_}, exp] ->
                 mkstr(Pstr_eval exp)
                | _ -> mkstr (Pstr_value ($2,List.rev $3))}
        | EXTERNAL val_ident COLON core_type EQUAL primitive_declaration
           { mkstr
               (Pstr_primitive
                  (mkrhs $2 2,
                   {pval_type=$4, pval_prim=$6;
                    pval_loc = symbol_rloc () }))}
        | TYPE type_declarations
            {mkstr (Pstr_type (List.rev $2))}
        | EXCEPTION UIDENT constructor_arguments
            {mkstr(Pstr_exception(mkrhs $2 2, $3))}
        (* *)    
        | EXCEPTION UIDENT EQUAL constr_longident
            {mkstr(Pstr_exn_rebind(mkrhs $2 2, mkloc $4 (rhs_loc 4)))}
        (* *)
        | MODULE UIDENT module_binding
            {mkstr (Pstr_module(mkrhs $2 2, $3))}
        | MODULE REC module_rec_bindings
            {mkstr (Pstr_recmodule(List.rev $3))}
        | MODULE TYPE ident EQUAL module_type
            {mkstr (Pstr_modtype(mkrhs $3 3, $5))}
        | OPEN mod_longident
            {mkstr (Pstr_open (mkrhs $2 2))}
        | CLASS class_declarations
             {mkstr (Pstr_class (List.rev $2))}
        | CLASS TYPE class_type_declarations
             {mkstr (Pstr_class_type (List.rev $3))}
        | INCLUDE module_expr {mkstr(Pstr_include $2)};
      #+END_SRC

***** module binding
      #+BEGIN_SRC ocaml
        module_binding:
          EQUAL module_expr {$2}
        | COLON module_type EQUAL module_expr
                {mkmod(Pmod_constraint($4,$2))}
        | LPAREN UIDENT COLON module_type RPAREN module_binding
                 {mkmod (Pmod_functor(mkrhs $2 2,$4, $6))};
        
        module_rec_bindings:
          module_rec_binding {[$1]}
        | module_rec_bindings AND module_rec_binding {$3::$1};
      #+END_SRC
      

***** module type

      #+BEGIN_SRC ocaml
        module_type:
          mty_longident {mkmty(Pmty_ident(mkrhs $1 1))}
        | SIG signature END {mkmty(Pmty_signature(List.rev $2))}
        | SIG signature error {unclosed "sig" 1 "end" 3}
        | FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
          %prec below_WITH {mkmty (Pmty_functor(mkrhs $3 3, $5, $8))}
        | module_type WITH with_constraints
                      {mkmty (Pmty_with($1,List.rev $3))}
        | MODULE TYPE OF module_expr {mkmty (Pmty_typeof $4)}
        | LPAREN module_type RPAREN {$2}
        | LPAREN module_type error {unclosed "(" 1 ")" 3};

      #+END_SRC
***** signature
      #+BEGIN_SRC ocaml
        signature:
          /*empty*/ {[]}
        | signature signature_item {$2::$1}
        | signature signature_item SEMISEMI {$2 :: $1};
        
        signature_item:
          VAL val_ident COLON core_type
              {mksig (Psig_value
                        (mkrhs $2 2,
                         {pval_type=$4; pval_prim=[];
                          pval_loc= symbol_rloc()}))}
        | EXTERNAL val_ident COLON core_type EQUAL primitive_declaration
              {mksig (Psig_value(mkrhs $2 2,
              {pval_type = $4; pval_prim = $6; pval_loc = symbol_rloc()}))}
        | TYPE type_declarations
              {mksig (Psig_type(List.rev $2))}
        | EXCEPTION UIDENT constructor_arguments
              {mksig(Psig_exception(mkrhs $2 2, $3))}
        | MODULE UIDENT module_declaration
                 { mksig(Psig_module(mkrhs $2 2, $3)) }
        | MODULE REC module_rec_declarations
                 { mksig(Psig_recmodule(List.rev $3)) }
        (**)         
        | MODULE TYPE ident
                 { mksig(Psig_modtype(mkrhs $3 3, Pmodtype_abstract)) }
        | MODULE TYPE ident EQUAL module_type
                 { mksig(Psig_modtype(mkrhs $3 3, Pmodtype_manifest $5)) }
        | OPEN mod_longident
               { mksig(Psig_open (mkrhs $2 2)) }
        | INCLUDE module_type
                  { mksig(Psig_include $2) }
        | CLASS class_descriptions
                { mksig(Psig_class (List.rev $2)) }
        | CLASS TYPE class_type_declarations
                { mksig(Psig_class_type (List.rev $3)) }
        ;
              
      #+END_SRC
***** module declaration
***** functions
     #+BEGIN_SRC ocaml
       let mkoption d =
         { ptyp_desc = Ptyp_constr(mknoloc (Ldot (Lident "*predef*", "option")), [d]);
           ptyp_loc = d.ptyp_loc}
     #+END_SRC
     #+BEGIN_SRC ocaml
       implementation_of_string "let a ?(u=3) b  = b + 1" |> Pprintast.print_structure std_formatter;;
       let a = fun ?(u = 3) -> fun b -> (b + 1)
       - : unit = ()
     #+END_SRC
     #+BEGIN_SRC ocaml
       implementation_of_string "let a ?(u=3) b  = b + 1";;
       - : Parsetree.structure =
       [{Parsetree.pstr_desc =
          Parsetree.Pstr_value (Asttypes.Nonrecursive,
           [({Parsetree.ppat_desc = Parsetree.Ppat_var {Asttypes.txt = "a"; loc = };
              ppat_loc = },
             {Parsetree.pexp_desc =
               Parsetree.Pexp_function ("?u",
                Some
                 {Parsetree.pexp_desc =
                   Parsetree.Pexp_constant (Asttypes.Const_int 3);
                  pexp_loc = },
                [({Parsetree.ppat_desc =
                    Parsetree.Ppat_var {Asttypes.txt = "u"; loc = };
                   ppat_loc = },
                  {Parsetree.pexp_desc =
                    Parsetree.Pexp_function ("", None,
                     [({Parsetree.ppat_desc =
                         Parsetree.Ppat_var {Asttypes.txt = "b"; loc = };
                        ppat_loc = },
                       {Parsetree.pexp_desc =
                         Parsetree.Pexp_apply
                          ({Parsetree.pexp_desc =
                             Parsetree.Pexp_ident
                              {Asttypes.txt = Longident.Lident "+"; loc = };
                            pexp_loc = },
                          [("",
                            {Parsetree.pexp_desc =
                              Parsetree.Pexp_ident
                               {Asttypes.txt = Longident.Lident "b"; loc = };
                             pexp_loc = });
                           ("",
                            {Parsetree.pexp_desc =
                              Parsetree.Pexp_constant (Asttypes.Const_int 1);
                             pexp_loc = })]);
                        pexp_loc = })]);
                   pexp_loc = })]);
              pexp_loc = })]);
         pstr_loc = }]
     #+END_SRC

**** terminals
***** simple terminals

      #+BEGIN_SRC ocaml
        name_tag:
            BACKQUOTE ident                             { $2 }
        ;
        rec_flag:
            /* empty */                                 { Nonrecursive }
          | REC                                         { Recursive }
        ;
        direction_flag:
            TO                                          { Upto }
          | DOWNTO                                      { Downto }
        ;
        private_flag:
            /* empty */                                 { Public }
          | PRIVATE                                     { Private }
        ;
        mutable_flag:
            /* empty */                                 { Immutable }
          | MUTABLE                                     { Mutable }
        ;
        virtual_flag:
            /* empty */                                 { Concrete }
          | VIRTUAL                                     { Virtual }
        ;
        override_flag:
            /* empty */                                 { Fresh }
          | BANG                                        { Override }
        ;
        opt_bar:
            /* empty */                                 { () }
          | BAR                                         { () }
        ;
        opt_semi:
          | /* empty */                                 { () }
          | SEMI                                        { () }
        ;
        subtractive:
          | MINUS                                       { "-" }
          | MINUSDOT                                    { "-." }
        ;
        additive:
          | PLUS                                        { "+" }
          | PLUSDOT                                     { "+." }
        ;
      #+END_SRC
      For nonterminal =virtual_flag= =name_tag=

      #+BEGIN_SRC ocaml
        `  a 3 ;;
        - : [> `a of int ] = `a 3
      #+END_SRC

      #+BEGIN_SRC ocaml
          | name_tag simple_expr %prec below_SHARP
              { mkexp(Pexp_variant($1, Some $2)) }
          | name_tag %prec prec_constant_constructor
              { mkexp(Pexp_variant($1, None)) }
          | name_tag pattern %prec prec_constr_appl
              { mkpat(Ppat_variant($1, Some $2)) }
          | name_tag
              { mkpat(Ppat_variant($1, None)) }
          | LBRACKETLESS opt_bar row_field_list GREATER name_tag_list RBRACKET |
              { mktyp(Ptyp_variant(List.rev $3, true, Some (List.rev $5))) }
        (* [< | > `a ]*)
        opt_present:
            LBRACKETGREATER name_tag_list RBRACKET      { List.rev $2 }
          | /* empty */                                 { [] }
      #+END_SRC
**** utilities
     In module =location=

*** [[file:~/ocaml-svn/parsing/lexer.mll][parsing/lexer.mll]]

*** [[file:~/ocaml-svn/parsing/lexer.ml][parsing/lexer]]

*** [[file:~/ocaml-svn/parsing/location.ml][parsing/location]]

*** [[file:~/ocaml-svn/parsing/longident.ml][parsing/longident]]

    #+BEGIN_SRC ocaml
      type t =
          Lident of string
        | Ldot of t * string
        | Lapply of t * t
    #+END_SRC


*** [[file:~/ocaml-svn/parsing/parse.ml][parsing/parse]]

    A *wrapper* of module *Parser*

    #+BEGIN_SRC ocaml
      val implementation : Lexing.lexbuf -> Parsetree.structure
      val interface : Lexing.lexbuf -> Parsetree.signature
      val toplevel_phrase : Lexing.lexbuf -> Parsetree.toplevel_phrase
      val use_file : Lexing.lexbuf -> Parsetree.toplevel_phrase list
    #+END_SRC
    
*** [[file:~/ocaml-svn/parsing/parser.ml][parsing/parser]]
    Generated code by *parser.mly*

*** [[file:~/ocaml-svn/parsing/printast.ml][parsing/printast]]

    Textual dumper for OCaml Parsetree

*** [[file:~/ocaml-svn/parsing/syntaxerr.ml][parsing/syntaxerr]]

*** [[file:~/ocaml-svn/parsing/pprintast.ml][parsing/pprintast]]

    pretty printer Ast into vanilla ocaml code  
