
\section{ocamlbuild}

The reason for \verb|ocamlbuild| in OCaml is to solve the complex scheme to
when building camlp4. But it's very useful in other aspects as well.

Your code is in the \verb|_build| directory. \verb|ocamlbuild| copies
the \verb|needed| source files and compiles them.  In \verb|_build|,
\verb|_log| file contains detailed building process. \verb|ocamlbuild|
automatically creates a symbol link to the executable it in the
current directory.  Hygiene rules at start up (.cmo, .cmi, or .o
should not appear outside of the \verb|_build|). Sometimes when you
want to mix c-stubs, you tag the .o object file \verb|precious| or
\verb|-no-hygiene|


Important Compile Flags 

\begin{spacing}{0.5}\small
\begin{tabular}{|c|c|}
\hline
option & comment \\
\hline
-quiet & \\
-verbose <level> & \\
-\textbf{documentation} & show rules and flags for a \textbf{specific} \verb|_tags| file
\\
-clean & \\
-r & Traverse directories by default\textit{true:traverse} \\
-I <path> & \\
-Is <path,...> & \\
-X <path> & \textit{ignore} directory \\
-Xs <path,...> & \\
-lib <flag> & link to ocaml library \textit{.cma} \\
-libs <flag,...> & \\
-mod <module> & link to ocaml module \\
-mods & \\
-pkg <package> & link to \textit{ocamlfind package} \\
-pkgs <...> & \\
-lflag  <flag> & ocamlc link flags \\
-lflags & \\
-cflag & ocamlc comple flags \\
-cflags & \\
-yaccflag &  Add to ocamlyacc flags, you can hack for \verb|menhir| \\
-yaccflags & \\
-lexflag & \\
-lexflags & \\
-pp & preprocessing flagss\\
-tag <tag> & add to default tags \\
-tags & \\
-show-tags & for \textit{debugging},\verb|ocamlbuild -show-tags target| \\
-ignore <module,...> & \\
-no-hygiene & \\
-no-plugin & \\
-just-plugin & just build myocamlbuild.ml \\
-use-menhir & \\
-use-jocaml & \\
-use-ocamlfild & \\
-build-dir & set \textit{build} directory (implies no-links)\\
-install-lib-dir <path> & \\
-install-bin-dir & \\
-ocamlc <command> & set the ocamlc command \\
-ocamlopt  & \\
-ocamldoc & \\
-ocamlyacc & \\
-menhir & set the menhir tool (use it after -use-menhir)\\
-ocamllex & \\
-ocamlmktop & \\
-ocamlrun & \\
--  & supply arguments \\
\hline
  \end{tabular}
\end{spacing}


Simple Examples

\begin{bluetext}
ocamlbuild -quiet xx.native -- args
ocamlbuild -quite -use-ocamlfind xx.native -- args
\end{bluetext}


You can pass flags to \verb|ocamlc| at compile time. i.e,
\verb|-cflags -I,+lablgtk,-rectypes|

You can link with \textit{ external} libraries. i.e,
\verb|-libs unix,num|.  You may need add the options below to make it
work if this not in OCaml's default search path
\verb|-cflags -I,/usr/local/lib/ocaml|
\verb|-lflags -I,/usr/local/lib/ocaml|


You can also build a library with specicfic modules included using
\verb|mllib| file

\begin{bluetext}
cat top_level.mllib    
Dir_top_level_util
Dir_top_level  
\end{bluetext}

Then you can \verb|ocamlbuild top_level.cma|, then you can use
\textbf{ocamlobjinfo} to see exactly which modules are compacted into
it.

\begin{bluetext}
ocamlobjinfo _build/top_level.cma | grep Unit  
Unit name: Dir_top_level_util
Unit name: Dir_top_level
\end{bluetext}

You can alo use  \verb|mlpack| file to do hierachical packing 
\todo{mlpack file}

You can also make use of \verb|_tags| file for convenience.  Every
source tree may have a \verb|_tags| file, and each target may have a
set of tags .
\begin{bluetext}
bash-3.2$ocamlbuild -show-tags test.ml

Tags for "test.ml":
  {. extension:ml, file:test.ml, ocaml, pkg_camlp4.macro, pkg_menhirLib,
     pkg_ulex, predefine_ulex.ml, quiet, syntax_camlp4o, traverse, use_menhir .}

bash-3.2$ ocamlbuild -show-tags test.byte
Tags for "test.byte":
  {. byte, extension:byte, file:test.byte, ocaml, pkg_menhirLib, pkg_ulex,
     program, quiet, traverse, use_menhir .}

bash-3.2$ ocamlbuild -show-tags test.native
Tags for "test.native":
  {. extension:native, file:test.native, native, ocaml, pkg_menhirLib,
     pkg_ulex, program, quiet, traverse, use_menhir .}

\end{bluetext}
%$

You can digest the output to get a general idea of how tags file work.
By preceding a tag with a minus sign, one can \verb|remove| tags from
one or more files.

The built-in \verb|_tags| file as follows:
\begin{bluetext}
<**/*.ml>   or <**/*.mli> or <**/*.ml.depends> : ocaml 
<**/*.byte> : ocaml, byte, program 
<**/*.native>: ocaml, native, program
<**/*.cma>:ocaml, byte,library
<**/*.cmxa>:ocaml,native,library
<**/*.cmo>:ocaml,byte
<**/*.cmx>:ocaml,native
\end{bluetext}
You can do some experiment do verify it, create a empty directory, and
make a dummy ml file, then type \verb|ocamlbuild -show-tags test.ml|,
you will get the output as follows 
\begin{bluetext}
Tags for "test.ml": {. extension:ml, file:test.ml, ocaml, quiet .}
\end{bluetext}

\verb|<**/*.ml>| means that \verb|.ml| files in \emph{current dir or
  sub dir}. A special tag made from the path name of the file relative
to the toplevel of the project, is automatically defined for each
file.  Just as above \verb|test.ml| will be tagged
\verb|file:test.ml|and also \verb|extension:ml|


Considering multiple directories:

Suppose our directory structure is as follows 
\begin{bluetext}
   |---bar
   |---baz
   |---foo
\end{bluetext}
Our tags file is 
\begin{bluetext}
<bar> or <baz> : include 
bash-3.2$ cat foo/main.ml
open Printf
let _ = begin
  print_int Barfile.i;
  print_int Bazfile.j;
end 
\end{bluetext}
%$
Here module \verb|Barfile| and \verb|Bazfile| lies in directries
\verb|bar,baz|. So, after typing ocamlbuild in
\verb|toplevel directory|, then your directory structure is as follows

\begin{bluetext}
   |-_build
   |---bar
   |---baz
   |---foo
   |-bar
   |-baz
   |-foo
\end{bluetext}

What \verb|ocamlbuild| did is explicit if you read \verb|_log|
\begin{bluetext}

bash-3.2$ cat _build/_log 
### Starting build.
# Target: foo/main.ml.depends, tags: { extension:ml, file:foo/main.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules foo/main.ml > foo/main.ml.depends
# Target: bar/barfile.ml.depends, tags: { extension:ml, file:bar/barfile.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules bar/barfile.ml > bar/barfile.ml.depends
# Target: baz/bazfile.ml.depends, tags: { extension:ml, file:baz/bazfile.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules baz/bazfile.ml > baz/bazfile.ml.depends
# Target: bar/barfile.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:bar/barfile.cmo, file:bar/barfile.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I bar -I baz -o bar/barfile.cmo bar/barfile.ml
# Target: baz/bazfile.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:baz/bazfile.cmo, file:baz/bazfile.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I baz -I bar -o baz/bazfile.cmo baz/bazfile.ml
# Target: foo/main.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:foo/main.cmo, file:foo/main.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I foo -I baz -I bar -o foo/main.cmo foo/main.ml
# Target: foo/main.byte, tags: { byte, dont_link_with, extension:byte, file:foo/main.byte, link, ocaml, program, quiet, traverse }
/opt/godi/bin/ocamlc.opt bar/barfile.cmo baz/bazfile.cmo foo/main.cmo -o foo/main.byte
# Compilation successful.
\end{bluetext}

%$

So, you can see that \verb|-I | flags was added for each included
directory and their source was copied to \_build, \verb|foo| was copied
was due to our target \verb|foo/main.byte|. They are still flat
structure actually. Ocamlbuild still views each directory as source
directory and do santity check. Each source tree should still be built
using ocamlbuild, it's not easy to mix with other build tools. You can
add \verb|-I| flags by hand, but the relative path does not work. I
did not find a perfect way to mix ocamlbuild with other build tools yet.



You can also  group your targets \verb|foo.itarget, foo.otarget|
\begin{bluetext}
cat foo.itarget
main.native
main.byte 
stuff.docdir/index.html    
\end{bluetext}
Then you can say \verb|ocamlbuild foo.otarget|


For preprocessing either \verb|-pp| or tags \verb|pp(cmd ...)| 

For debugging and profiling either \verb|.d.byte, .p.native| or
\verb|true:debug|


To build documentation, create a file called \verb|foo.odocl|, then
write the modules you want to document, then build the target
\verb|foo.docdir/index.html|. When you use \textit{-keep-code} flag in
myocamlbuild.ml(\ref{myocamlbuild}), \textit{only} document of exposed
modules are kept, not very useful.  Add such a line in your
\verb|myocamlbuild.ml| plugin.
\verb| flag ["ocaml"; "doc"] & S[A"-keep-code"];| Or you can do it by
hand
\verb|ocamlbuild -ocamldoc 'ocamlfind ocamldoc -keep-code' foo.docdir/index.html|
\verb|ocamldep| seems to be \textbf{ lightweight}.  It's weird when
you have \verb|mli| file, \verb|-keep-code| does not work

\todo{Glob Patterns}




\textbf{With lex yacc, ocamlfind }


\verb|.mll .mly| supported by default, you can use menhir
\verb|-use-menhir| or add a line \verb|true : use_menhir|

Add a line in tags file
\begin{bluetext}
<*.ml> : pkg_sexplib.syntax, pkg_batteries.syntax, syntax_camlp4o
\end{bluetext}

Here \verb|syntax_camlp4o| is translated by
myocamlbuild.ml(\ref{myocamlbuild}) to \verb|-syntax camlp4o| to pass
to ocamlfind pkg needs \textbf{ocamlbuild plugin} support.


Examples with Syntax extension 
\begin{bluetext}
<*.ml>: package(lwt.unix), package(lwt.syntax), syntax(camlp4o) # only needs lwt.syntax when prepossessing
"prog.byte": package(lwt.unix)
\end{bluetext}
There are two style to cooperate with syntax extension, one way is
above, combined with ocamlfind, in most case it works, but it is not
very well considering you want to build \verb|.ml.ppo| and other
stuff. The other way is to use \verb|pp| directly, you could simlink
your extension file to \verb|camlp4 -where|. I found this way is more
natural. There's another way which is used local(\ref{use_pa}), we
will introduce it later.

We can see different styles here.
\begin{bluetext}
<pa_*r.{ml,cmo,byte}> : pkg_dynlink , pp(camlp4rf ), use_camlp4_full
<*_ulex.{byte,native}> : pkg_ulex 
<*_ulex.ml> : syntax_camlp4o,pkg_ulex,pkg_camlp4.macro  
<*_r.ml>:syntax_camlp4r,pkg_camlp4.quotations.r,pkg_camlp4.macro,pkg_camlp4.extend 
pa_vector_r.ml:syntax_camlp4r,pkg_camlp4.quotations.r,pkg_camlp4.extend,pkg_sexplib.syntax
<pa_vector_r.{cmo,byte,native}>:pkg_dynlink,use_camlp4_full,pkg_sexplib 
<*_o.ml> : syntax_camlp4o,pkg_sexplib.syntax 
"map_filter_r.ml" : pp(camlp4r -filter map)
"wiki_r.ml" or "wiki2_r.ml"  : pp(camlp4rf -filter meta), use_camlp4_full
"wiki2_r.mli" : use_camlp4_full 
\end{bluetext}

The \verb|.mli| file also needs tags. For syntax extension,
\textbf{order matters}. For more information, check out \textbf{
  camlp4/examples} in the ocaml source tree. When you use \verb|pp|
flag, you need to specify the path to \verb|pa_xx.cmo|, so symbol link
may help.  Since 3.12,, you can use \verb|-use-ocamlfind| to
activate. ocamlfind predicates can be activated with the
\verb|predicate(...)| tag.


\begin{bluetext}
<*.ml>: package(lwt.unix), package(lwt.syntax), syntax(camlp4o)
"prog.byte": package(lwt.unix)
\end{bluetext}

ocamlbuild cares white space, \textbf{ take care when write tags file}

\subsection{Principles}
Rules 

A rule is composed of triple (Tags, Targets $\rightarrow$ Dependencies).
\verb|ocamlbuild| looks for all rules that are valid for this target.
You can set \verb|-verbose 10| to get the backtrace in case of a
failure.

\href{http://nicolaspouillard.fr/ocamlbuild/html/Signatures.PLUGIN.html}{Plugin
API Documentation}

There are 3 stages,(\textit{hygiene}, \textit{options}(parsing the
command line options), \textit{rules}(adding the default rules to the
system)). You can add hooks to what you want.


\begin{bluetext}
{Before|After}_{options|hygiene|rules}
\end{bluetext}

To change the options, simply refer to the \verb|Options| module.

\begin{ocamlcode}
sub_modules "Ocamlbuild_plugin";;
module This_module_name_should_not_be_used :
    module Pathname :
        module Operators :
    module Tags :
        module Operators :
    module Command :
    module Outcome :
    module String :
    module List :
    module StringSet :
    module Options :
    module Arch :
    module Findlib :  
\end{ocamlcode}
Here \verb|sub_modules| is a helper function which will be introduced
later(some ideas, combined with ocamlgraph and camlp4-parser to
generate a graph?).  


\subsection{Practical bits}
Useful API
\verb|Pathname.t,Tags.eltstring|
List the tags of a file \verb|tags_of_pathname|
Tag a file \verb|tag_file|
Untag a file \verb|tag_file "x.ml" ["-use_unix"]|
\verb|Arch.print_info|

\begin{ocamlcode}
rule;;
- : string ->
    ?tags:string list ->
    ?prods:string list ->
    ?deps:string list ->
    ?prod:string ->
    ?dep:string ->
    ?stamp:string ->
    ?insert:[ `after of string | `before of string | `bottom | `top ] ->
    Ocamlbuild_plugin.action -> unit
= <fun>
\end{ocamlcode}
The first argument is the name of the rule(unique required),
\verb|~dep| is the dependency, \verb|~prod| is the production. For
example with \verb|~dep:"%.ml" ~prod:"%.byte"|, you can produce
``bla.byte'' from ``bal.ml''. There are some predefined commands such
as Unix commands(cp,mv,...).

flag
\begin{ocamlcode}
flag ["ocaml"; "compile"; "thread"'] (A "-thread")  
\end{ocamlcode}
It says when tags \verb|ocaml, compile, thread| are met together,
\verb|-thread| option should be emitted.

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{toolchain/code/command_intf.ml}

\verb|module Options| contains refs to be configured
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{toochain/code/ocamlbuild/options.mli}

\subsection{Plugin}

Some Examples

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{toolchain/code/ocamlbuild/myocamlbuild.2.ml}

\label{use_pa}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{toolchain/code/ocamlbuild/myocamlbuild.3.ml}

\begin{bluetext}
 "bar.ml": camlp4o, use_openin
 <foo/*.ml> or <baz/**/*.ml>: camlp4r, use_openin
 "pa_openin.ml": use_camlp4, camlp4o  
\end{bluetext}

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{code/ocamlbuild/myocamlbuild.4.ml}


\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{code/ocamlbuild/myocamlbuild.5.ml}


Mixed with C stubs 

My point is that tag your c code precious, then mv it into \_build
directory. Then link it by hand.

\begin{bluetext}

_tags:
<single_write.o> : precious

Makefile:
_build/single_write.o: single_write.o
	test -d $(LIB) || mkdir $(LIB)
	cp single_write.o $(LIB)
# tag single_write.o precious
write.cma:  _build/single_write.o write.cmo
	cd $(LIB); ocamlc -custom -a -o single_write.o write.cmo

\end{bluetext}

Sometimes perfect solution does not exist, at least I don't find,
write \verb|myocamlbuild.ml| to drive the building process is not cost
effective.

Another typical \verb|myocamlbuild.ml| plugin.
\label{myocamlbuild}
\inputminted[fontsize=\scriptsize, ]{ocaml}{/Users/bobzhang1988/myocamlbuild/myocamlbuild.ml}

Interaction with git (.gitignore)
\begin{bluetext}
_log
_build
*.native
*.byte
*.d.native
*.p.byte  
\end{bluetext}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
