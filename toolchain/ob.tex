\section{Ocamlbuild}
The reason for \verb|ocamlbuild| in OCaml is to solve the complex
scheme to when building camlp4. But it's very useful in other aspects
as well.

The building process is done in the \verb|_build|
directory. \verb|ocamlbuild| copies the \verb|needed| source files and
compiles them.  In \verb|_build|, \verb|_log| file contains detailed
building process. \verb|ocamlbuild| automatically creates a symbol
link to the executable in the current directory.  Hygiene rules at
start up (\textit{.cmo, .cmi, or .o} should not appear outside of the
\verb|_build|). Sometimes when you want to mix c-stubs, you tag the
\textit{.o} object file \verb|precious| or \verb|-no-hygiene|

% \begin{spacing}{0.5}\small
%   \begin{tabular}{|c|c|}
\begin{longtable}{|c|c|}
  \hline
option & comment \\
  \endfirsthead
\hline
-quiet & \\
-verbose <level> & \\
-\textbf{documentation} & show rules and flags for a \textbf{specific} \verb|_tags| file
\\
-clean & \\
\textbf{-r} & Traverse directories by default\textit{true:traverse} \\
-I <path> & \\
-Is <path,...> & \\
-X <path> & \textit{ignore} directory \\
-Xs <path,...> & \\
-lib <flag> & link to ocaml library \textit{.cma} \\
-libs <flag,...> & \\
-mod <module> & link to ocaml module \\
-mods & \\
-pkg <package> & link to \textit{ocamlfind package} \\
-pkgs <...> & \\
-lflag  <flag> & ocamlc link flags \\
-lflags & \\
\textbf{-cflag} & ocamlc comple flags \\
-cflags & \\
-yaccflag &  Add to ocamlyacc flags, you can hack for \verb|menhir| \\
-yaccflags & \\
-lexflag & \\
-lexflags & \\
-pp & preprocessing flagss\\
-tag <tag> & add to default tags \\
-tags & \\
\textbf{-show-tags} & for \textit{debugging},\verb|ocamlbuild -show-tags target| \\
-ignore <module,...> & \\
-no-hygiene & \\
-no-plugin & \\
\textbf{-just-plugin} & just build myocamlbuild.ml \\
-use-menhir & \\
-use-jocaml & \\
-use-ocamlfild & \\
-build-dir & set \textit{build} directory (implies no-links)\\
-install-lib-dir <path> & \\
-install-bin-dir & \\
-ocamlc <command> & set the ocamlc command \\
-ocamlopt  & \\
-ocamldoc & \\
-ocamlyacc & \\
-menhir & set the menhir tool (use it after -use-menhir)\\
-ocamllex & \\
-ocamlmktop & \\
-ocamlrun & \\
\textbf{- -}  & supply arguments \\
\hline
% \end{tabular}
\end{longtable}
% \end{spacing}
\captionof{table}{OCAMLBUILD FLAGS \label{ocamlbuild flags}}

The snippet below is a very simple example.

\begin{bashcode}
ocamlbuild -quiet xx.native -- args
ocamlbuild -quite -use-ocamlfind xx.native -- args
\end{bashcode}


You can pass flags to \verb|ocamlc| at compile time. i.e,
\verb|-cflags -I,+lablgtk,-rectypes|

You can link with \textit{ external} libraries(\textit{.cma}). i.e,
\verb|-libs unix,num|.  You may need add the options below to make it
work if this not in OCaml's default search path
\verb|-cflags -I,/usr/local/lib/ocaml|
\verb|-lflags -I,/usr/local/lib/ocaml|


You can also build a library with specicfic modules included using
\verb|mllib| file

\begin{bashcode}
cat top_level.mllib    
Dir_top_level_util
Dir_top_level  
\end{bashcode}

Then you can \verb|ocamlbuild top_level.cma|, then you can use
\textbf{ocamlobjinfo} to see exactly which modules are compacted into
it.

\begin{bashcode}
ocamlobjinfo _build/top_level.cma | grep Unit  
Unit name: Dir_top_level_util
Unit name: Dir_top_level
\end{bashcode}

You can alo use  \verb|mlpack| file to do hierachical packing 
\todo{mlpack file}

You can also make use of \verb|_tags| file for convenience.  Every
source tree may have a \verb|_tags| file, and each target may have a
set of tags .

\begin{bashcode}
bash-3.2$ocamlbuild -show-tags test.ml

Tags for "test.ml":
  {. extension:ml, file:test.ml, ocaml, pkg_camlp4.macro, pkg_menhirLib,
     pkg_ulex, predefine_ulex.ml, quiet, syntax_camlp4o, traverse, use_menhir .}

bash-3.2$ ocamlbuild -show-tags test.byte
Tags for "test.byte":
  {. byte, extension:byte, file:test.byte, ocaml, pkg_menhirLib, pkg_ulex,
     program, quiet, traverse, use_menhir .}

bash-3.2$ ocamlbuild -show-tags test.native
Tags for "test.native":
  {. extension:native, file:test.native, native, ocaml, pkg_menhirLib,
     pkg_ulex, program, quiet, traverse, use_menhir .}

 \end{bashcode}
 \captionof{listing}{OCAMLBUILD TAGS \label{ocamlbuild tags}}
%$

 You can digest the output to get a general idea of how tags file
 work.  By preceding a tag with \textit{a minus sign}, one can
 \verb|remove| tags from one or more files.

The built-in \verb|_tags| file as follows:

\begin{bashcode}
<**/*.ml>   or <**/*.mli> or <**/*.ml.depends> : ocaml 
<**/*.byte> : ocaml, byte, program 
<**/*.native>: ocaml, native, program
<**/*.cma>:ocaml, byte,library
<**/*.cmxa>:ocaml,native,library
<**/*.cmo>:ocaml,byte
<**/*.cmx>:ocaml,native
\end{bashcode}
\captionof{listing}{OCAMLBUILD DEFAULT TAGS \label{ocamlbuild default tags}}
You can do some experiment do verify it, create a empty directory, and
make a dummy ml file, then type \verb|ocamlbuild -show-tags test.ml|,
you will get the output as follows 

\begin{bashcode}
Tags for "test.ml": {. extension:ml, file:test.ml, ocaml, quiet .}
\end{bashcode}

\verb|<**/*.ml>| means that \verb|.ml| files in \emph{current dir or
  sub dir}. A special tag made from the path name of the file relative
to the toplevel of the project, is automatically defined for each
file.  Just as above \verb|test.ml| will be tagged
\verb|file:test.ml|and also \verb|extension:ml|

\subsubsection{multiple directories}
Considering multiple directories:

Suppose our directory structure is as follows 

\begin{bashcode}
   |---bar
   |---baz
   |---foo
\end{bashcode}
Our tags file is 

\begin{bashcode}
<bar> or <baz> : include 
bash-3.2$ cat foo/main.ml
open Printf
let _ = begin
  print_int Barfile.i;
  print_int Bazfile.j;
end 
\end{bashcode}
%$
Here module \verb|Barfile| and \verb|Bazfile| lies in directries
\verb|bar,baz|. So, after typing ocamlbuild in
\verb|toplevel directory|, then your directory structure is as follows

\begin{bashcode}
   |-_build
   |---bar
   |---baz
   |---foo
   |-bar
   |-baz
   |-foo
\end{bashcode}

What \verb|ocamlbuild| did is explicit if you read \verb|_log|

\begin{bashcode}
bash-3.2$ cat _build/_log 
### Starting build.
# Target: foo/main.ml.depends, tags: { extension:ml, file:foo/main.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules foo/main.ml > foo/main.ml.depends
# Target: bar/barfile.ml.depends, tags: { extension:ml, file:bar/barfile.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules bar/barfile.ml > bar/barfile.ml.depends
# Target: baz/bazfile.ml.depends, tags: { extension:ml, file:baz/bazfile.ml, ocaml, ocamldep, quiet, traverse }
/opt/godi/bin/ocamldep.opt -modules baz/bazfile.ml > baz/bazfile.ml.depends
# Target: bar/barfile.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:bar/barfile.cmo, file:bar/barfile.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I bar -I baz -o bar/barfile.cmo bar/barfile.ml
# Target: baz/bazfile.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:baz/bazfile.cmo, file:baz/bazfile.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I baz -I bar -o baz/bazfile.cmo baz/bazfile.ml
# Target: foo/main.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:foo/main.cmo, file:foo/main.ml, implem, ocaml, quiet, traverse }
/opt/godi/bin/ocamlc.opt -c -I foo -I baz -I bar -o foo/main.cmo foo/main.ml
# Target: foo/main.byte, tags: { byte, dont_link_with, extension:byte, file:foo/main.byte, link, ocaml, program, quiet, traverse }
/opt/godi/bin/ocamlc.opt bar/barfile.cmo baz/bazfile.cmo foo/main.cmo -o foo/main.byte
# Compilation successful.
\end{bashcode}

%$

So, you can see that \verb|-I | flags was added for each included
directory and their source was copied to \_build, \verb|foo| was
copied was due to our target \verb|foo/main.byte|. They are still
\textit{flat} structure actually. Ocamlbuild still views each
directory as source directory and do santity check. Each source tree
should still be built using ocamlbuild, it's not easy to mix with
other build tools. You can add \verb|-I| flags by hand, but the
relative path does not work. I did not find a perfect way to mix
ocamlbuild with other build tools yet.


\subsubsection{grouping targets}
You can also  group your targets \verb|foo.itarget, foo.otarget|

\begin{bashcode}
cat foo.itarget
main.native
main.byte 
stuff.docdir/index.html    
\end{bashcode}
Then you can say \verb|ocamlbuild foo.otarget|

For preprocessing either \verb|-pp| or tags \verb|pp(cmd ...)| 

For debugging and profiling either \verb|.d.byte, .p.native| or
\verb|true:debug|

To build \textit{documentation}, create a file called \verb|foo.odocl|, then
write the modules you want to document, then build the target
\verb|foo.docdir/index.html|. When you use \textit{-keep-code} flag in
myocamlbuild.ml(\ref{myocamlbuild}), \textit{only} document of exposed
modules are kept, not very useful.  Add such a line in your
\verb|myocamlbuild.ml| plugin

\begin{ocamlcode}
flag ["ocaml"; "doc"] & S[A"-keep-code"];
\end{ocamlcode}
Or you can do it by hand

\begin{bashcode}
|ocamlbuild -ocamldoc 'ocamlfind ocamldoc -keep-code' foo.docdir/index.html
\end{bashcode}
\verb|ocamldep| seems to be \textbf{ lightweight}.  It's weird when
you have \verb|mli| file, \verb|-keep-code| does not work.

\todo{Glob Patterns}




\subsubsection{With lex yacc, ocamlfind }
\verb|.mll .mly| supported by default, you can use menhir
\verb|-use-menhir| or add a line \verb|true : use_menhir|
Add a line in tags file

\begin{bashcode}
<*.ml> : pkg_sexplib.syntax, pkg_batteries.syntax, syntax_camlp4o
\end{bashcode}

Here \verb|syntax_camlp4o| is translated by
myocamlbuild.ml(\ref{myocamlbuild}) to \verb|-syntax camlp4o| to pass
to ocamlfind. Pkg needs \textbf{ocamlbuild plugin} support.

Examples with Syntax extension

\begin{bashcode}
<*.ml>: package(lwt.unix), package(lwt.syntax), syntax(camlp4o) # only needs lwt.syntax when prepossessing
"prog.byte": package(lwt.unix)
\end{bashcode}
There are two style to cooperate with syntax extension, one way is
above, combined with ocamlfind, in most case it works, but it is not
very well considering you want to build \verb|.ml.ppo| and other
stuff. The other way is to use \verb|pp| directly, you could simlink
your extension file to \verb|camlp4 -where|. I found this way is more
natural. There's another way which is used local(\ref{use_pa}), we
will introduce it later.

We can see different styles here.

\begin{bashcode}
<pa_*r.{ml,cmo,byte}> : pkg_dynlink , pp(camlp4rf ), use_camlp4_full
<*_ulex.{byte,native}> : pkg_ulex 
<*_ulex.ml> : syntax_camlp4o,pkg_ulex,pkg_camlp4.macro  
<*_r.ml>:syntax_camlp4r,pkg_camlp4.quotations.r,pkg_camlp4.macro,pkg_camlp4.extend 
pa_vector_r.ml:syntax_camlp4r,pkg_camlp4.quotations.r,pkg_camlp4.extend,pkg_sexplib.syntax
<pa_vector_r.{cmo,byte,native}>:pkg_dynlink,use_camlp4_full,pkg_sexplib 
<*_o.ml> : syntax_camlp4o,pkg_sexplib.syntax 
"map_filter_r.ml" : pp(camlp4r -filter map)
"wiki_r.ml" or "wiki2_r.ml"  : pp(camlp4rf -filter meta), use_camlp4_full
"wiki2_r.mli" : use_camlp4_full 
\end{bashcode}
Actually, you does not need \textit{pp} here, ocamlbuild is smart
enough to infer it as \textit{.ml} tag.


The \textit{.mli} file also needs tags. For syntax extension,
\textbf{order matters}. For more information, check out \textbf{
  camlp4/examples} in the ocaml source tree. When you use \verb|pp|
flag, you need to specify the path to \verb|pa_xx.cmo|, so symbol link
may help.  Since 3.12,, you can use \verb|-use-ocamlfind| to
activate. ocamlfind predicates can be activated with the
\verb|predicate(...)| tag.


\begin{bashcode}
<*.ml>: package(lwt.unix), package(lwt.syntax), syntax(camlp4o)
"prog.byte": package(lwt.unix)
\end{bashcode}

ocamlbuild cares white space, \textbf{ take care when write tags file}
\subsubsection{Use Camlp4}

Something should be taken care, some built-in tags like
\textit{use\_camlp4}, \textit{use\_camlp4\_full} was propogated
from \textit{.ml} to \textit{.odoc}, or more, they should be
used separately from the syntax extensions

\begin{bashcode}
  <gen_printer.ml> : use_camlp4, camlp4rf
  # Target: gen_printer.ml.depends, tags: { camlp4rf, extension:ml, file:gen_printer.ml, ocaml, ocamldep, quiet, traverse, use_camlp4 }
ocamlfind ocamldep -pp camlp4rf -modules gen_printer.ml > gen_printer.ml.depends # cached
  # Target: util.mli.depends, tags: { extension:mli, file:util.mli, ocaml, ocamldep, quiet, traverse, use_camlp4 }
ocamlfind ocamldep -modules util.mli > util.mli.depends # cached
  # Target: util.cmi, tags: { byte, compile, extension:mli, file:util.mli, interf, ocaml, quiet, traverse, use_camlp4 }
ocamlfind ocamlc -annot -c -I +camlp4 -o util.cmi util.mli # cached
  # Target: gen_printer.odoc, tags: { camlp4rf, doc, extension:ml, file:gen_printer.ml, implem, ocaml, quiet, traverse, use_camlp4 }
ocamlfind ocamldoc -dump gen_printer.odoc -I +camlp4 -I +camlp4 -pp camlp4rf gen_printer.ml # cached
  # Target: foo.docdir/gen_printer.dot, tags: {  }
  rm -rf foo.docdir/gen_printer.dot
# Target: foo.docdir, tags: {  }
mkdir -p foo.docdir
# Target: foo.docdir/gen_printer.dot, tags: { doc, docfile, extension:docdir, extension:dot, file:foo.docdir, file:foo.docdir/gen_printer.dot, ocaml, quiet, traverse }
ocamlfind ocamldoc -load gen_printer.odoc -dot -o foo.docdir/gen_printer.dot
# Compilation successful.
\end{bashcode}

\subsection{Principles}
Rules 

A rule is composed of triple (Tags, Targets $\rightarrow$ Dependencies).
\verb|ocamlbuild| looks for all rules that are valid for this target.
You can set \verb|-verbose 10| to get the backtrace in case of a
failure.

\href{http://nicolaspouillard.fr/ocamlbuild/html/Signatures.PLUGIN.html}{Link
  to Plugin API Documentation}

There are 3 stages,(\textit{hygiene}, \textit{options}(parsing the
command line options), \textit{rules}(adding the default rules to the
system)). You can add hooks to what you want.

\begin{bashcode}
{Before|After}_{options|hygiene|rules}
\end{bashcode}

To change the options, simply refer to the \verb|Options| module.

\begin{ocamlcode}
sub_modules "Ocamlbuild_plugin";;
module This_module_name_should_not_be_used :
    module Pathname :
        module Operators :
    module Tags :
        module Operators :
    module Command :
    module Outcome :
    module String :
    module List :
    module StringSet :
    module Options :
    module Arch :
    module Findlib :  
\end{ocamlcode}
Here \verb|sub_modules| is a helper function which will be introduced
later(some ideas, combined with ocamlgraph and camlp4-parser to
generate a graph?).  


\subsection{Write plugin}
Useful API: \verb|Pathname.t,Tags.eltstring| List the tags of a file
\verb|tags_of_pathname| Tag a file \verb|tag_file| Untag a file
\verb|tag_file "x.ml" ["-use_unix"]| \verb|Arch.print_info|

\begin{ocamlcode}
rule;;
- : string ->
    ?tags:string list ->
    ?prods:string list ->
    ?deps:string list ->
    ?prod:string ->
    ?dep:string ->
    ?stamp:string ->
    ?insert:[ `after of string | `before of string | `bottom | `top ] ->
    Ocamlbuild_plugin.action -> unit
= <fun>
\end{ocamlcode}
The first argument is the name of the rule(unique required),
\verb|~dep| is the dependency, \verb|~prod| is the production. For
example with \mint{ocaml}|~dep:"%.ml" ~prod:"%.byte"| you can produce
``bla.byte'' from ``bal.ml''. There are some predefined commands such
as Unix commands(cp,mv,...).


\begin{ocamlcode}
flag ["ocaml"; "compile"; "thread"'] (A "-thread")  
\end{ocamlcode}
\captionof{listing}{OCAMLBUILD plugin sample \label{ocamlbuild sample}}
It says when tags \verb|ocaml, compile, thread| are met together,
\verb|-thread| option should be emitted.

\inputminted[fontsize=\scriptsize]{ocaml}{code/ocamlbuild/command_intf.ml}
\captionof{listing}{Command module interface \label{Command}}
\verb|module Options| contains refs to be configured
\inputminted[ fontsize=\scriptsize, ]{ocaml}{code/ocamlbuild/options.mli}
\captionof{listing}{Options module interface \label{Options}}

\subsubsection{Samples}
Some Examples
\inputminted[fontsize=\scriptsize]{ocaml}{code/ocamlbuild/alphacaml.ml}
\captionof{listing}{Using $\alpha$caml }

\inputminted[fontsize=\scriptsize]{ocaml}{code/ocamlbuild/open_in.ml}

\begin{bashcode}
 "bar.ml": camlp4o, use_openin
 <foo/*.ml> or <baz/**/*.ml>: camlp4r, use_openin
 "pa_openin.ml": use_camlp4, camlp4o  
\end{bashcode}

\inputminted[fontsize=\scriptsize]{ocaml}{code/ocamlbuild/ejecting.ml}
\captionof{listing}{Ejecting Shell Command\label{ejecting}}

\inputminted[fontsize=\scriptsize]{ocaml}{code/ocamlbuild/dep.ml}
\captionof{listing}{Add dependency\label{ocamlbuild dependency}}

\subsubsection{Mixing with C stubs}
\label{sec:mixing-with-c}
My point is that tag your c code precious, then mv it into \_build
directory. Then link it by hand.

\begin{bashcode}
_tags:
<single_write.o> : precious
Makefile:
_build/single_write.o: single_write.o
	test -d $(LIB) || mkdir $(LIB)
	cp single_write.o $(LIB)
# tag single_write.o precious
write.cma:  _build/single_write.o write.cmo
	cd $(LIB); ocamlc -custom -a -o single_write.o write.cmo
\end{bashcode}

There's built in support, solution is:

\begin{ocamlcode}
    dep ["link"; "ocaml"; "use_plus_stubs"] ["plus_stubs.o"];
    flag["link"; "ocaml"; "byte"] (S[A"-custom"]);
\end{ocamlcode}
OCamlbuild can invoke gcc to do the building process. The tags file is
like this

\begin{bluetext}
<plus.{byte,native}> : use_plus_stubs  
\end{bluetext}
Notice that \verb|-custom| is only for byte link, native link will
link it by default. You can also enrich your \textit{runtime} without
linking to each byte file everytime.

\begin{bashcode}
  ocamlc -make-runtime -o new_ocamlrun progc.o a_c_library.a
  ocamlc -o vbcname.exe -use-runtime new_ocamlrun progocaml.cmo
\end{bashcode}
Instead of new runtime, you can also build a toplevlel linking c
functions

\begin{bashcode}
  ocamlmktop -custom -o ftop progc.o a_c_library.a ex.ml
\end{bashcode}
So you see, you have 4 choices, enrich enriovment, toplevel, bytecode,
native code


Another typical \verb|myocamlbuild.ml| plugin.
\label{myocamlbuild}
\inputminted[fontsize=\scriptsize]{ocaml}{/Users/bobzhang1988/myocamlbuild/myocamlbuild.ml}


\subsection{OCamlbuild in the toplevel }

\begin{ocamlcode}
#directory "+ocamlbuild";;
#load "ocamlbuildlib.cma";;
open Ocamlbuild_plugin
open Command 
\end{ocamlcode}

Now you can do a lot of amazing things in the toplevel and write
complex plugin system.

\subsection{Building interface files}

\begin{bashcode}
<ppo.{cmo,mli}> : use_camlp4
\end{bashcode}

Take care, Tags \textit{.cmi} file does not make sense , tag \textit{.mli} file


\begin{bashcode}
# Target: ppo.cmi, tags: { byte, compile, extension:mli, file:ppo.mli, interf, ocaml, quiet, traverse, use_camlp4 }
ocamlfind ocamlc -annot -c -I +camlp4 -o ppo.cmi ppo.mli
\end{bashcode}


\subsubsection{Interaction with Git}
\begin{bashcode}
_log
_build
*.native
*.byte
*.d.native
*.p.byte  
\end{bashcode}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
