\section{Standard OCaml Develop Tools}



\begin{table}[ht]
\caption{Ocaml Compiler Tools}
\centering

\begin{tabular}{|l|l|}
  \hline
  ocaml & toplevel top \\
  \hline
  ocamlrun & bytecode interpreter \\
  \hline
  ocamlc & bytecode batch compiler \\
  \hline
  ocamlopt & native code batch compiler \\
  \hline
  ocamlc.opt & \textit{optimized} bytecode batch compiler \\
  \hline
  ocamlopt.opt & \textit{optimized} native code batch compiler \\
  \hline
  ocamlmktop & new \textit{toplevel} constructor \\
  \hline
\end{tabular}
\label{table:ocamlcoption}
\end{table}

The optimized compilers are themselves compiled with the Objective
Caml native compiler.  They compile \textit{faster} but are otherwise
\textit{identical} to their unoptimized counterparts.

\textbf{Compilation Unit} For the interactive system, the unit of
compilation corresponds to a phrase of the language. For the batch
compiler, the unit of compilation is two files: the source file, and
the interface file. The \textit{compiled interface} is used for both
the bytecode and native code compiler.

\begin{table}
  \centering
  \begin{tabular}{|l|l|}
  \hline
  extension & meaning \\
  .ml & source \\
  .mli & interface \\
  .cmi & compiled interface \\
  .cmo & object file (byte) \\
  .cma & library object file(bytecode) \\
  .cmx & object file (native) \\
  .cmxa & library object file(native) \\
  \hline
  .c & c source \\
  .o & c object file (native) \\
  .a & c library object file (native) \\
  \hline
  \end{tabular}
  \caption{ocaml file name extension}
  \label{tab:ocaml_file_ext}
\end{table}

  


\begin{table}
  \centering
  \begin{tabular}{|l|l|}
  \hline
  -a & construct a runtime library \\
  -c & compile \textit{without} linking \\
  -o name\_of\_executabular & specify the name of the executabular \\
 \emph{-linkall} & link with \textit{all} libraries used \\
  -i & \textit{display all } compiled global declarations, generate
  .mli file \\
  \emph{-pp} & preprocessor \\
  -unsafe & \textit{turn off} index checking \\
  -v & display version \\
  -w list & choose among the list the level of warning message \\
  -impl file & indicate that \textit{file} is a caml source(.ml) \\
  -intf file & as a caml interface(.mli) \\
  -I dir & add directory in the list of directories \\
  \hline
  -thread & light process \\
  -g, -noassert & linking  with debug information\\
  \textit{-custom, -cclib, -ccopt, -cc} & standalone executeblel \\
  \textit{-make-runtime, -use-runtime} & runtime \\
  \textit{-output-obj} & c interface \\
  \hline
  \end{tabular}
  \caption{ocamlc options}
  \label{tab:ocamlc_options}
\end{table}

\begin{table}
  \centering
  \begin{tabular}{|l|l|}
    \hline
  A/a & enable/disable all messages \\
  F/f & partial application in a sequence \\
  P/p & incomplete pattern matching \\
  U/u & missing cases in pattern matching \\
  X/x & enable/disable all other messages \\
  M/m and V/v & for hidden object \\
  \hline
  \end{tabular}
  \caption{warning option}
  \label{tab:warning_opt}
\end{table}

About warning messages (Table \ref{tab:warning_opt}) , the compiler chooses the (A)
by default.  turn off some warnings sometimes is helpful, for example
\begin{bashcode}
ocamlbuild -cflags -w,aPF top_level.cma    
\end{bashcode}


\begin{table}
  \centering
  \begin{tabular}{|l|l|}
    \hline
  \textit{-compact} & optimize the produced code for space \\
  -S & keeps the assembly code in a file \\
  -inline level & set the aggressiveness of inlining \\
  \hline
  \end{tabular}
  \caption{ocamlopt option}
  \label{tab:ocamlopt_option}
\end{table}


\begin{table}
  \centering
  \begin{tabular}{|l|l|}
    \hline
  -I dir & adds the directory \\
  -unsafe & no bounds checking \\
  \hline
  \end{tabular}
  \caption{toplevel option}
  \label{tab:toplevel_opt}
\end{table}
OCAMLMKTOP( Table \ref{tab:toplevel_opt}) is ofen used for \textit{pulling native object}
code libraries(typically written in C) into a new toplevel.  \textit{
  -cclib libname, -ccopt optioin, -custom, -I dir -o exectuable }
For example:
\begin{bashcode}
ocamlmktop -custom -o mytoplevel graphics.cma \
   -cclib -I/usr/X11/lib -cclib -lX11
\end{bashcode}
  
This \textit{standalone} exe(-custom) wil be \textit{linked} to the
library X11(libX11.a) which in turn will be looked up in the path
\textit{/usr/X11/lib}

A standalone exe is a program that \textit{does not } depend on OCaml
installation to run.  The OCaml \textit{native} compiler produces standalone
executabulars by default. But \textit{without} \textit{-custom} option, the
\textit{bytecode} compiler produces an executabular which requires the
\textit{bytecode interpreter ocamlrun}

\begin{bashcode}
ocamlc test.ml -o a
ocamlc -custom test.ml -o b
\end{bashcode}
\begin{bluetext}
-rwxr-xr-x   1 bob  staff    12225 Dec 23 16:31 a
-rwxr-xr-x   1 bob  staff   198804 Dec 23 16:31 b
\end{bluetext}
You can see the size of \verb|b|with the ocamlrun is way more bigger
than \verb|a|

\begin{bashcode}
bash-3.2$ cat a | head -n 1
#!/Users/bob/SourceCode/ML/godi/bin/ocamlrun
\end{bashcode}
% $

Without \textit{-custom}, it depends on \textit{ocamlrun}. With
\textit{-custom}, it contains the \textit{Zinc} interpreter as well as
the program bytecode, this file can be executed directly or copied to
another machien(using the same CPU/Operating System).  Still, the
inclusion of machine code means that stand-alone executalbes are not
protabular to other systems or other architectures.

\textbf{Optimization} It is necessary to not create \textit{intermediate
  closures} in the case of application on several arguments. For
example, when the function \textit{add} is applied with two integers,
it is not useful to create the first closure corresponding to the
function of applying add to the first argument. It is necessary to
note that the creation of a closure would \textit{allocate} certain
memory space for the environment and would require the recovery of
that memory space in the future. \textit{Automatic memory recovery} is
the second major performance concern, along with environment.
