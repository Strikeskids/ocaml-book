\section{Polymorphic Variants}

\subsection{Coercion}
There are three different kinds of varints \textit{[< ... ], [...], [>
  ...]}.

They are subtly different in terms of unification and coercion.

First, let's consider the cases coercion happens, there are nine cases
together, when the domain of type coercion is like \textit{[...]}

The output is as follows:

\begin{ocamlcode}
let f x = (x : [`a] :> [<`a|`b]);;
val f : [ `a ] -> [ `a ] = <fun>

let f x = (x : [>`a] :> [<`a|`b]);;
val f : ([< `a | `b > `a ] as 'a) -> 'a = <fun>

let f x = (x : [<`a] :> [< `a|`b]);;
val f : ([< `a ] as 'a) -> 'a = <fun>
\end{ocamlcode}
\captionof{listing}{Polymorphic Coercion 1}
You can see when the codomain of type coercion is a closed type
\textit{[<...]}, the coercion does not have effect, it may add more
constraint to the typing relation, but the input and output always
share the same type.

Here \textit{[< `a | `b > `a ]} reads a subset of \textit{`a} or
\textit{`b} with the constraint that \textit{`b > `a}.


\begin{ocamlcode}
let f x = (x : [`a] :> [ `a|`b]);;
val f : [ `a ] -> [ `a | `b ] = <fun>

let f x = (x : [<`a] :> [ `a|`b]);;
val f : [< `a ] -> [ `a | `b ] = <fun>

let f x = (x : [> `a] :> [ `a|`b]);;
val f : [ `a | `b ] -> [ `a | `b ] = <fun>  
\end{ocamlcode}
\captionof{listing}{Polymorphic Coercion 2}

There's no surprise here.

\begin{ocamlcode}
let f x = (x : [ `a] :> [> `a|`b]);;
val f : [ `a ] -> [> `a | `b ] = <fun>

let f x = (x : [> `a] :> [> `a|`b]);;
val f : ([> `a | `b ] as 'a) -> 'a = <fun>

let f x = (x : [< `a] :> [> `a|`b]);;
val f : [< `a ] -> [> `a | `b ] = <fun>
\end{ocamlcode}
\captionof{listing}{Polymorphic Coercion 3}
The output is reasonable here as well.

\subsection{Unification}
\label{sec:unification}

There's some uncertainity in closed variant and open variant. So
unification will make sense here.

For example, the code below will give an error

\begin{ocamlcode}
let f (x: [` a  ]) : [`a | `b ] = x  
\end{ocamlcode}

\begin{ocamlcode}
  let f (x: [` a  ]) : [< `a | `b ] = x ;;
  val f : [ `a ] -> [ `a ] = <fun>
\end{ocamlcode}
There's some varity in closed variant, so the compiler will try to
unify it, for closed variant, it can be \textit{unified with variant types
that contains less or the same constructors}.

For open variants,  it can only be unified with variant types that
contains more or equal constructors.

Now we can go back to see how unification works
\begin{ocamlcode}
  let f x  =  (x: [> `a] :> [< `a | `b ]);;
  val f : ([< `a | `b > `a ] as 'a) -> 'a = <fun>
\end{ocamlcode}
The type of f reads that it can be either \textit{`a} or \textit{`b}
with a constraint that \textit{`b > `a},  so if you tried
\textit{f `a}, \textit{f `b}, both will work, since \textit{`b} is of
type \textit{[> `b]} and can be unified with \textit{[>`a]}, but
the following code will break:

\begin{ocamlcode}
let x = (`b : [`b]);;
val x : [ `b ] = `b
# f x;;
Characters 2-3:
  f x;;
    ^
Error: This expression has type [ `b ] but an expression was expected of type
         [< `a | `b > `a ]
       The first variant type does not allow tag(s) `a
\end{ocamlcode}

\subsection{Coersion Example}
\label{sec:coersion-example}

The code below shows how to define type abbreviations to reduce type
coercion:

\inputminted[fontsize=\scriptsize]{ocaml}{code/types/test_poly_coer.ml}

\subsection{Problem}

\begin{ocamlcode}
let f x = match x  with `a -> `b | x -> x ;;
val f : ([> `a | `b ] as 'a) -> 'a = <fun>
\end{ocamlcode}

Here the \textit{`a} will never appear as output, but we could not
encode the invariant here.


\subsection{Advanced Usage}
\label{sec:advanced-usage}

\todo{introducing the example in the original paper}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
