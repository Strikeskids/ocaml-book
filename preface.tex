\begin{quotation}

  This is a book about advanced programming in \verb|O'Caml|.  It's
  assumed that you are already familiar with the basic ideas of the
  different programming paradigms, for example, functional
  programming, object-oriented programming, meta programming.

  I am a graduate student of \verb|University of Pennsylvania| right
  now. I love programming and spend a lot of time digging different
  fancy languages and the underlying theories, including \verb|C|,
  \verb|C++|, \verb|Ocaml|, \verb|Haskell|, \verb|Common Lisp|,
  \verb|Perl| and know tiny bits about \verb|Coq|, \verb|Prolog|,
  \verb|Python| as well.

  \verb|Haskell| is the most elegant language that I ever used and is
  the language that brought me to the Alice's wonderland of function
  programming, while \verb|Ocaml| is the most productive one for me at
  this time, since its support of multiple paradigms and
  practicalism. Haskell's \verb|lazy evaluation| renders it
  impractical for real world programming. I love Haskell's all good
  parts except \verb|lazy evaluation|. Even for meta-programming,
  Haskell's nice support of generic programming and ad-hoc overloading
  makes it less painful compared with programming in \verb|camlp4|,
  \verb|camlp4| supports quasiquotation mechanism fully, however.

  Another interesting language is \verb|Common Lisp|, the most
  interesting book that I read about programming is \textit{Paradigms
    of Artificial Intelligence Programming: Case Studies in Common
    Lisp} which was written using \verb|Common Lisp|. Some other
  interesting books about \verb|Lisp| are \verb|On Lisp| and
  \verb|Let Over Lambda|. \verb|Clojure| is a modern dialect of
  \verb|Common Lisp|, while its implementation is a bit weak at this
  time. Lisp's good part mainly lies in \verb|meta-programming|.
  However, from mine point of view, type safety is a really good tool
  to maintain the quality of your pieces of software. And the good
  parts of \verb|Lisp| are largely absorbed by \verb|Haskell|,
  \verb|OCaml|, it's not too hard to do meta programming in Ocaml,
  while sometimes even more convenient.


  To conclude, \verb|OCaml| is the most productive language at this
  time, and that's why I am writing this book.

  
  This is still a book in progress. Don't distribute it without any
  permission.
\end{quotation}
