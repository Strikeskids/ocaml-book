\section{ocamlgraph}
\label{sec:ocamlgraph}

\textit{ocamlgraph} is a sex library which deserve well-documentation.

Check the file \textit{pack.ml}, it provides a succint interface.

\begin{ocamlcode}
  module Digraph = Generic(Imperative.Digraph.AbstractLabeled(I) (I))
  module Graph = Generic(Imperative.Graph.AbstractLabeled(I) (I))
\end{ocamlcode}

The Imperative implementation is in \textit{imperative.ml}, 

A nice trick, to bind open command to use graphviz to open the file,
then it will do the sync up automatically

\inputminted[fontsize=\scriptsize
]{ocaml}{code/graph/dag.ml}
\captionof{listing}{Play with DAG  \label{DAG}}

Different modules have corresponding algorithms
\textit{Graph.Pack} requires its label being integer 



\subsection{Undirected graph}
\label{sec:undirected-graph}

so, as soon as you want to label your vertices with strings and your
edges with floats, you should use functor. Take
\textit{ConcreteLabeled} as an example


  \begin{ocamlcode}
open Graph 
module V = struct
  type t = string
  let compare = Pervasives.compare
  let hash = Hashtbl.hash
  let equal = (=)
end
module G = Imperative.Digraph.Concrete (V)
let g = G.create ()
let _ = G.(begin 
  add_edge g "a" "b";
  add_edge g "a" "c";
  add_edge g "b" "d";
  add_edge g "b" "d"
end )
module Display = struct 
  include G
  let vertex_name v = (V.label v)
  let graph_attributes _ = []
  let default_vertex_attributes _ = []
  let vertex_attributes _ = []
  let default_edge_attributes _ = []
  let edge_attributes _ = []
  let get_subgraph _ = None
end 
module Dot_ = Graphviz.Dot(Display)
let _ = 
  let out = open_out "g.dot" in
  finally (fun _ -> close_out out) (fun g -> 
    let fmt =
      (out |> Format.formatter_of_output) in 
    Dot_.fprint_graph fmt g ) g
  \end{ocamlcode}
  
  It seems that Graphviz.Dot is used to display directed graph, Graphviz.Neato is used to display undirected graph.

  here is a useful example to visualize the output generated by ocamldep.
  \begin{ocamlcode}
open Batteries_uni 
open Graph 
module V = struct
  type t = string
  let compare = Pervasives.compare
  let hash = Hashtbl.hash
  let equal = (=)
end
module StringDigraph = Imperative.Digraph.Concrete (V)
module Display = struct 
  include StringDigraph
  open StringDigraph
  let vertex_name v = (V.label v)
  let graph_attributes _ = []
  let default_vertex_attributes _ = []
  let vertex_attributes _ = []
  let default_edge_attributes _ = []
  let edge_attributes _ = []
  let get_subgraph _ = None
end 

module DisplayG = Graphviz.Dot(Display)


let dot_output g file = 
  let out = open_out file in
  finally (fun _ -> close_out out) (fun g -> 
    let fmt =
      (out |> Format.formatter_of_output) in 
    DisplayG.fprint_graph fmt g ) g


let g_of_edges edges = StringDigraph.(
  let g = create () in 
  let _ = Stream.iter (fun (a,b) -> add_edge g a  b) edges in
  g 
)

let line = "path.ml: Hashtbl Heap List Queue Sig Util"

let edges_of_line line = 
  try 
    let (a::b::res) = 
      Pcre.split ~pat:".ml:" ~max:3  line in 
    let v_a = 
      let _ =  a.[0]<- Char.uppercase a.[0] in 
      a  in 
    let v_bs = 
      (Pcre.split ~pat:"\\s+" b ) |> List.filter (fun x -> x <> "") in 
    let edges = List.map (fun v_b -> v_b, v_a ) v_bs in 
    edges 
  with exn -> invalid_arg ("edges_of_line : " ^ line)

let lines_stream_of_channel chan = Stream.from (fun _ -> 
    try Some (input_line chan) with End_of_file -> None );;

let edges_of_channel chan = Stream.(
  let lines = lines_stream_of_channel chan in 
  let edges = lines |> map (edges_of_line |- of_list) |> concat in 
  edges 
)


let graph_of_channel = edges_of_channel |- g_of_edges 

let _ = 
  let stdin = open_in Sys.argv.(1) in 
  let g = graph_of_channel stdin in begin
  Printf.printf "writing to dump.dot\n";
  dot_output g "dump.dot";
  Printf.printf "finished\n"
  end
\end{ocamlcode}


\end{enumerate}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
