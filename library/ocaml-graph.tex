
ocamlgraph is a sex library which deserve well-documentation.

\begin{enumerate}
\item simple usage in the module \textit{Graph.Pack.Digraph}

  \begin{redcode}
  se_str "label" "PDig.V";;
\end{redcode}

\begin{bluecode}
  type label = int
  val create : label -> t
  val label : t -> label    
\end{bluecode}

Follow this file, you could know how to build a graph,
A nice trick, to bind open command to use graphviz to open the 
file, then it will do the sync automatically 
and you can \textit{\#u ``open *.dot''}, so nice
\begin{bluecode}
module PDig = Graph.Pack.Digraph
let g = PDig.Rand.graph ~v:10 ~e:20 () 
(* get dot output file *)
let _ = PDig.dot_output g "g.dot" 
(* use gnu/gv to show *)
let show_g = PDig.display_with_gv;;

let g_closure = PDig.transitive_closure ~reflexive:true g 
(** get a transitive closure *)
let _ = PDig.dot_output g_closure "g_closure.dot"

let g_mirror = PDig.mirror g 
let _ = PDig.dot_output g_mirror "g_mirror.dot"

let g1 = PDig.create ()
let g2 = PDig.create ()


let [v1;v2;v3;v4;v5;v6;v7 ] = List.map PDig.V.create [1;2;3;4;5;6;7]

let _ = PDig.( begin
  add_edge g1 v1 v2;
  add_edge g1 v2 v1;
  add_edge g1 v1 v3;
  add_edge g1 v2 v3;
  add_edge g1 v5 v3;
  add_edge g1 v6 v6;
  add_vertex g1 v4
  end 
)

let _ = PDig.( begin
  add_edge g2 v1 v2;
  add_edge g2 v2 v3;
  add_edge g2 v1 v4;
  add_edge g2 v3 v6;
  add_vertex g2 v7
end
)

let g_intersect = PDig.intersect g1 g2 
let g_union = PDig.union g1 g2 

let _ = 
  PDig.(
    let f = dot_output in begin
    f g1 "g1.dot";
    f g2 "g2.dot";
    f g_intersect "g_intersect.dot"; 
    f g_union "g_union.dot"
    end 
  )
\end{bluecode}

  \begin{redcode}
module PDig = Graph.Pack.Digraph    
sub_modules "PDig";;    
\end{redcode}

\begin{bluecode}
    module V :
    module E :
    module Mark :
    module Dfs :
    module Bfs :
    module Marking : sig val dfs : t -> unit val has_cycle : t -> bool end
    module Classic :
    module Rand :
    module Components :
    module PathCheck :
    module Topological :  
  \end{bluecode}
  Different modules have corresponding algorithms
\item hierachical

  \begin{redcode}
sub_modules "Graph" (** output too big *)    
\end{redcode}
idea. can we draw a tree graph for this??

Graph.Pack requires its label being integer 
\begin{redcode}
sub_modules "Graph.Pack"  
\end{redcode}

\begin{bluecode}
    module Digraph :
        module V :
        module E :
        module Mark :
        module Dfs :
        module Bfs :
        module Marking :
        module Classic :
        module Rand :
        module Components :
        module PathCheck :
        module Topological :
    module Graph :
        module V :
        module E :
        module Mark :
        module Dfs :
        module Bfs :
        module Marking :
        module Classic :
        module Rand :
        module Components :
        module PathCheck :
        module Topological :
\end{bluecode}

\item hierachical
  for undirected graph

\begin{alternate}
Graph.Pack.(Di)Graph
Undirected imperative graphs with edges and vertices labeled with integer.
Graph.Imperative.Matrix.(Di)Graph 
Imperative Undirected Graphs implemented with adjacency matrices, of course integer(Matrix)


Graph.Imperative.(Di)Graph
Imperative Undirected Graphs.
Graph.Persistent.(Di)Graph
Persistent Undirected Graphs.
\end{alternate}

Here we have functor \textit{Graph.Imperative.Graph.Concrete},
\textit{Graph.Imperative.Graph.Abstract},
\textit{Graph.Imperative.Graph.ConcreteLabeled},
\textit{Graph.Imperative.Graph.AbstractLabeled}


we see that
\begin{bluetext}
module Abstract: 
functor (V : Sig.ANY_TYPE) -> Sig.IM  with type V.label = V.t and type E.label = unit

module AbstractLabeled: 
functor (V : Sig.ANY_TYPE) -> 
functor (E : Sig.ORDERED_TYPE_DFT) -> Sig.IM  with type V.label = V.t and type E.label = E.t

module Concrete: 
functor (V : Sig.COMPARABLE) -> Sig.I  with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
	  and type E.label = unit

module ConcreteBidirectional: 
functor (V : Sig.COMPARABLE) -> Sig.I  with type V.t = V.t and type V.label = V.t and type E.t = V.t * V.t
and type E.label = unit

module ConcreteBidirectionalLabeled: 
functor (V : Sig.COMPARABLE) -> 
functor (E : Sig.ORDERED_TYPE_DFT) -> Sig.I  with type V.t = V.t and type V.label = V.t
and type E.t = V.t * E.t * V.t and type E.label = E.t

module ConcreteLabeled: 
functor (V : Sig.COMPARABLE) -> 
functor (E : Sig.ORDERED_TYPE_DFT) -> Sig.I  with type V.t = V.t and type V.label = V.t
	    and type E.t = V.t * E.t * V.t and type E.label = E.t

          \end{bluetext}

          so, as soon as you want to label your vertices with strings and your edges with floats, you should use functor. Take ConcreteLabeled as an example


          \begin{bluetext}
module V = struct
  type t = string
  let compare = Pervasives.compare
  let hash = Hashtbl.hash
  let equal = (=)
end
module E = struct
  type t = float
  let compare = Pervasives.compare
  let default = 0.0
end
module X = Graph.Imperative.Graph.ConcreteLabeled (V) (E);;
module Y = Graph.Imperative.Digraph.ConcreteLabeled (V) (E);; 

(**
    val add_edge : t -> vertex -> vertex -> unit
    val add_edge_e : t -> edge -> unit
    val remove_edge : t -> vertex -> vertex -> unit
    val remove_edge_e : t -> edge -> unit

    Not only that, but the V and E structure will work for
    persistent and directed graphs that are concretelabeled,
    and you can switch by replacing Imperative with Persistent
    , and Graph with Digraph.    
    *)

module W = struct
  type label = float
  type t = float
  let weight x = x (* edge label -> weight *)
  let compare = Pervasives.compare
  let add = (+.)
  let zero = 0.0
  end

module Dijkstra = Graph.Path.Dijkstra (X) (W);;
  
\end{bluetext}
\item another example (edge unlabeled, directed graph) 

  \begin{bluecode}
open Graph 
module V = struct
  type t = string
  let compare = Pervasives.compare
  let hash = Hashtbl.hash
  let equal = (=)
end
module G = Imperative.Digraph.Concrete (V)
let g = G.create ()
let _ = G.(begin 
  add_edge g "a" "b";
  add_edge g "a" "c";
  add_edge g "b" "d";
  add_edge g "b" "d"
end )
module Display = struct 
  include G
  let vertex_name v = (V.label v)
  let graph_attributes _ = []
  let default_vertex_attributes _ = []
  let vertex_attributes _ = []
  let default_edge_attributes _ = []
  let edge_attributes _ = []
  let get_subgraph _ = None
end 
module Dot_ = Graphviz.Dot(Display)
let _ = 
  let out = open_out "g.dot" in
  finally (fun _ -> close_out out) (fun g -> 
    let fmt =
      (out |> Format.formatter_of_output) in 
    Dot_.fprint_graph fmt g ) g
  \end{bluecode}
  It seems that Graphviz.Dot is used to display directed graph, Graphviz.Neato is used to display undirected graph.

  here is a useful example to visualize the output generated by ocamldep.
  \begin{bluecode}
open Batteries_uni 
open Graph 
module V = struct
  type t = string
  let compare = Pervasives.compare
  let hash = Hashtbl.hash
  let equal = (=)
end
module StringDigraph = Imperative.Digraph.Concrete (V)
module Display = struct 
  include StringDigraph
  open StringDigraph
  let vertex_name v = (V.label v)
  let graph_attributes _ = []
  let default_vertex_attributes _ = []
  let vertex_attributes _ = []
  let default_edge_attributes _ = []
  let edge_attributes _ = []
  let get_subgraph _ = None
end 

module DisplayG = Graphviz.Dot(Display)


let dot_output g file = 
  let out = open_out file in
  finally (fun _ -> close_out out) (fun g -> 
    let fmt =
      (out |> Format.formatter_of_output) in 
    DisplayG.fprint_graph fmt g ) g


let g_of_edges edges = StringDigraph.(
  let g = create () in 
  let _ = Stream.iter (fun (a,b) -> add_edge g a  b) edges in
  g 
)

let line = "path.ml: Hashtbl Heap List Queue Sig Util"

let edges_of_line line = 
  try 
    let (a::b::res) = 
      Pcre.split ~pat:".ml:" ~max:3  line in 
    let v_a = 
      let _ =  a.[0]<- Char.uppercase a.[0] in 
      a  in 
    let v_bs = 
      (Pcre.split ~pat:"\\s+" b ) |> List.filter (fun x -> x <> "") in 
    let edges = List.map (fun v_b -> v_b, v_a ) v_bs in 
    edges 
  with exn -> invalid_arg ("edges_of_line : " ^ line)

let lines_stream_of_channel chan = Stream.from (fun _ -> 
    try Some (input_line chan) with End_of_file -> None );;

let edges_of_channel chan = Stream.(
  let lines = lines_stream_of_channel chan in 
  let edges = lines |> map (edges_of_line |- of_list) |> concat in 
  edges 
)


let graph_of_channel = edges_of_channel |- g_of_edges 

let _ = 
  let stdin = open_in Sys.argv.(1) in 
  let g = graph_of_channel stdin in begin
  Printf.printf "writing to dump.dot\n";
  dot_output g "dump.dot";
  Printf.printf "finished\n"
  end
\end{bluecode}


\end{enumerate}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
