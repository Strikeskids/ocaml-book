
\subsection{caltech ocaml book}


  
polymorphic variants
  \begin{enumerate}
  \item simple example

\begin{alternate}
let string_of_number = function `Integer i -> i;;
val string_of_number : [< `Integer of 'a ] -> 'a = <fun>
\end{alternate}
    
\begin{ocamlcode}  
# let string_of_number = function
    |`Integer i -> i
    |_ -> invalid_arg "string_of_number";;
  \end{ocamlcode}
\begin{ocamlcode}  
  val string_of_number : [> `Integer of 'a ] -> 'a = <fun>
\end{ocamlcode}  

\begin{ocamlcode}
let test0 = function 
  |`Int i -> i

let test1 = function 
  |`Int i -> i 
  | _ -> invalid_arg "invalid arg in test1"

let test2 = function 
  |x -> test0 x

let test3 = function 
  |x -> test1 x

(* let test4 : [> `Real of 'a | `Int of 'a ] -> 'a = function 
   |`Real x -> x *)
   | x -> test0 (x:> [< `Int of 'a])  *)

let test5 = function 
  |`Real x -> x 
  | x -> test1 x 
  
\end{ocamlcode}

\begin{ocamlcode}
val test0 : [< `Int of 'a ] -> 'a = <fun>
val test1 : [> `Int of 'a ] -> 'a = <fun>
val test2 : [< `Int of 'a ] -> 'a = <fun>
val test3 : [> `Int of 'a ] -> 'a = <fun>
val test5 : [> `Int of 'a | `Real of 'a ] -> 'a = <fun>
\end{ocamlcode}

for open union, it's easy to reuse, but \textbf{unsafe},
for closed union, hard to use, since the type checker is
conservative


\begin{alternate}

test1 `Test;;
Exception: Invalid_argument "invalid arg in test1".

test0 `Test;;
Characters 6-11:
  test0 `Test;;
        ^^^^^
Error: This expression has type [> `Test ]
       but an expression was expected of type [< `Int of 'a ]
       The second variant type does not allow tag(s) `Test
\end{alternate}
     






  \item \textbf{define polymorphic variant type }

\begin{alternate}
type number = [> `Integer of int | `Real of float ];;
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: A type variable is unbound in this type declaration.
In type [> `Integer of int | `Real of float ] as 'a
the variable 'a is unbound

type 'a number = 'a constraint 'a = [>`Integer of int | `Real of float]

let zero : 'a number = `Zero;;
val zero : [> `Integer of int | `Real of float | `Zero ] number = `Zero


type number = [< `Integer of int | `Real of float ];;
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: A type variable is unbound in this type declaration.
In type [< `Integer of int | `Real of float ] as 'a
the variable 'a is unbound
# type number = [ `Integer of int | `Real of float ];;
type number = [ `Integer of int | `Real of float ]


\end{alternate}

  \item \textbf{sub-typing for polymorphic variants}

\begin{ocamlcode}
  [`A] :> [`A | `B]
\end{ocamlcode}  
since you know how to handle A and B, then you know how to handle A

\begin{alternate}
let f x = (x:[`A] :> [`A | `B ]);;
val f : [ `A ] -> [ `A | `B ] = <fun>
\end{alternate}

ocaml does has width and depth subtyping
if t1 :> t1' and t2 :> t2' then (t1,t2) :> (t1',t2')

\begin{alternate}
let f x = (x:[`A] * [`B] :> [`A|`C] * [`B | `D]);; 
val f : [ `A ] * [ `B ] -> [ `A | `C ] * [ `B | `D ] = <fun>


let f x = (x : [ `A | `B ] -> [ `C ] :> [ `A ] -> [ `C | `D ]);;
val f : ([ `A | `B ] -> [ `C ]) -> [ `A ] -> [ `C | `D ] = <fun>
\end{alternate}

  \item variance notation \\
    if you don't write the + and -, ocaml will \textbf{infer} them for you ,
    but when you write abstract type in module type signatures, it makes sense.
    variance annotations \textbf{allow you to expose the subtyping properties} of your type
    in an interface, without exposing the representation.

\begin{ocamlcode}
type (+'a, +'b) t = 'a * 'b
type (-'a,+'b) t = 'a -> 'b 
module M : sig
  type (+'a,'+b) t
end = struct
  type ('a,'b) t = 'a * 'b 
end
\end{ocamlcode}
ocaml did the check when you define it, so you can not define it arbitrarily

  \item \textbf{co-variant} helps polymorphism

\begin{alternate}
module M : sig
    type +'a t
    val embed : 'a -> 'a t
  end = struct
    type 'a t = 'a
    let embed x = x
end ;;
M.embed []  ;;
- : 'a list M.t = <abstr>
\end{alternate}


  \item example

\begin{alternate}
type suit = [ `Club | `Diamond | `Heart | `Spade ]
  
let winner = function `Heart -> true | #suit -> false;;
val winner : [< suit ] -> bool = <fun>
let winner2 = function `Unknown -> true |#suit -> false;;
val winner2 : [< `Club | `Diamond | `Heart | `Spade | `Unknown ] -> bool =
  <fun>

(* the variant tag does not belong to a particular type *)

let winner3 : (suit -> bool) = function `Unknown -> true | #suit -> false;;
                                          ^^^^^^^^
Warning 11: this match case is unused.
val winner3 : suit -> bool = <fun>

\end{alternate}

  \end{enumerate}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
