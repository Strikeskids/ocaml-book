\subsection{Ocaml for scientists}
\label{sec:ocaml-scientists}
\begin{itemize}
\item caveat
  \begin{itemize}
  \item string char
    \verb|'a' = '\097'|
    \verb|"Hello world".[4]|

\begin{alternate}
  [|1;2;3|].(1)
  2 
\end{alternate}

  \item objects

\begin{ocamlcode}

(* it's a type class type *)
class type number = object
  method im:float
  method re:float 
end
\end{ocamlcode}

\begin{ocamlcode}
class complex x y = object 
    val x = x
    val y = y
    method re:float = x
    method im:float = y
end ;;
let b : number = new complex 3. 4.
\end{ocamlcode}

\begin{alternate}
# let b = new complex 3. 4.;;
val b : complex = <obj>
# let b : number = new complex 3. 4.;;
val b : number = <obj>
 \end{alternate}

\begin{ocamlcode} 
# let make_z x y = object
    val x : float = x
    val y : float = y
    method re = x
    method im = y
    end;;
  \end{ocamlcode}
\begin{ocamlcode}  
val make_z : float -> float -> < im : float; re : float > = <fun>
\end{ocamlcode}

class type is kinda interface

  
\begin{ocamlcode}
# let abs_number (z:number) = 
       let sqr x = x *. x in 
       sqrt (sqr z#re +. sqr z#im);;
     \end{ocamlcode}
     
think class as a module 


  \item asr (arith) (**) lsr
  \item elements

\begin{alternate}
  [1;2;3;4] |> Set.of_list |> Set.elements;;
  - : int list = [1; 2; 3; 4]
\end{alternate}


  \end{itemize}
\item convention
\item GMP (GNU library for arbitrary precision arithmetic)

\begin{ocamlcode}
module type INT_RANGE = sig
type t
val make : int -> int -> t
end 
\end{ocamlcode}


\item Hashtbl(create, Make)
  Hahsing is another form of structural comparison and should not be applied
  {\bf to abstract types}
  \emph{Semantically equivalent sets are likely to produce different hashes}
  notice \textit{Map.empty is polymorphic, Hashtbl.empty is monomorphic}
\end{itemize}


%%% Local Variables: 
%%% mode: LaTex
%%% TeX-master: "../master"
%%% End: 
