
Ulex \textbf{ support unicode}, while ocamllex don't, the tags file is
as follows

\begin{bluetext} 
$ cat tags
<*_ulex.ml> : syntax_camlp4o,pkg_ulex
<*_ulex.{byte,native}> : pkg_ulex
\end{bluetext} %$

Use default myocamlbuild.ml, like \verb|ln -s ~/myocamlbuild.ml| and
make a symbol link \verb|pa_ulex.cma| to camlp4 directory,this is
actually not necessary but sometimes for \verb| debugging purpose|,
as follows, this is pretty easy 

 \verb| camlp4o pa_ulex.cma -printer OCaml test_ulex.ml -o test_ulex.ppo|


Ulex does not support \verb| as | syntax as ocamllex.

\begin{redcode} 
let regexp number = ['0'-'9'] + 
let regexp line = [^'\n']* ('\n' ?)  
let u8l = Ulexing.utf8_lexeme 
let rec lexer1 arg1 arg2 .. = lexer 
   |regexp -> action |..  
and lexer2 arg1 arg2 .. = lexer
   |regexp -> action |...
\end{redcode}

\textbf{Roll back} 

Ulexing.rollback lexbuf, so for string lexing, you
can rollback one char, and \textit{plugin your string lexer}, but
\textit{not generally usefull}, ulex \textit{does not support shortest
mode yet}. Sometimes the semantics of rolling back is not what you
want as recursive descent parser.

\textbf{Abstraction with macro package} 

Since you need inline to do
macro prepossessing, so use syntax extension macro to \textbf{ inline}
your code,


\begin{bluetext}
 <*_ulex.ml> : syntax_camlp4o,pkg_ulex,pkg_camlp4.macro
 <*_ulex.{byte,native}> : pkg_ulex
\end{bluetext}

Attention!  Since you use ocamlbuild to build, then you need to copy
you include files to \verb|_build| if you use relative path in
\textbf{INCLUDE} macro, otherwise you should use absolute path.

 You can predefine some regexps (copied from ocaml source code)
\verb| parsing/lexer.ml|.

\inputminted{ocaml}{/Users/bobzhang1988/predefine_ulex.ml}


Ulex interface

Roughly equivalent to the module Lexing, except that its lexbuffers
handles Unicode code points  OCaml type \verb|int| in the range
\verb|0.. 0x10ffff| instead of bytes (OCamltype : \verb|char|).

    You can customize implementation for lex buffers, define a module
L which implements \emph{start,next,mark, and backtrack and the Error
exception}.  They need not work on a type named lexbuf, you can use
the type name you want.  Then, just do in your \emph{ulex-processed}
source, before the first lexer specification \verb|module Ulexing = L|
If you inspect the processed output by camlp4, you can see that the
generated code \emph{introducing Ulexing } very \emph{late} and
actually use very limited functions, other functions are just provided
for your convenience, and it did not have any type annotations, so you
really can customize it. I think probably ocamllex can do the similar
trick.
    
\inputminted{ocaml}{code/ulex_intf.mli}
    
Ulex does not handle line position, you have only global char
position, but we are using emacs, not matter too much

\textbf{ATTENTION}

When you use ulex to generate the code, make sure to write the
interface by yourself, the problem is that when you use the default
interface, it will generate \verb|__table__|, and different file may
overlap this name, when you open the module, it will cause a disaster,
so the best to do is write your \verb|.mli| file.

And when you write lexer, make sure you write the default branch,
check the generated code, otherwise its behavior is weird.

\verb|camlp4of -parser macro pa_ulex.cma test_calc.ml -printer o|
\textbf{Example}

Here is the example of simple basic lexer 
\inputminted{ocaml}{code/basic_ulex.ml}

%%% Local Variables: %%% mode: latex %%% TeX-master: "master" %%% End:
