
Ulex \textbf{ support unicode}, while ocamllex don't, the tags file is
as follows

\begin{bluetext} 
$ cat tags
 <*_ulex.ml> : syntax_camlp4o,pkg_ulex
<*_ulex.{byte,native}> : pkg_ulex
\end{bluetext} %$

Use default myocamlbuild.ml, like \emph{ln -s ~/myocamlbuild.ml} and
make a symbol link \verb|pa_ulex.cma| to camlp4 directory,this is
actually not necessary but sometimes for \textbf{ debugging purpose},
as follows, this is pretty easy 

 \verb| camlp4o pa_ulex.cma -printer OCaml test_ulex.ml -o test_ulex.ppo|


Ulex does not support \textit{ as } syntax as ocamllex.

\begin{redcode} 
let regexp number = ['0'-'9'] + 
let regexp line = [^'\n']* ('\n' ?)  
let u8l = Ulexing.utf8_lexeme 
let rec lexer1 arg1 arg2 .. = lexer 
   |regexp -> action |..  
and lexer2 arg1 arg2 .. = lexer
   |regexp -> action |...
\end{redcode}

\textbf{Roll back} 

Ulexing.rollback lexbuf, so for string lexing, you
can rollback one char, and \textit{plugin your string lexer}, but
\textit{not generally usefull}, ulex \textit{does not support shortest
mode yet}. Sometimes the semantics of rolling back is not what you
want as recursive descent parser.

\textbf{Abstraction with macro package} 

Since you need inline to do
macro prepossessing, so use syntax extension macro to \textbf{ inline}
your code,


\begin{bluetext}
 <*_ulex.ml> : syntax_camlp4o,pkg_ulex,pkg_camlp4.macro
 <*_ulex.{byte,native}> : pkg_ulex
\end{bluetext}

Attention!  Since you use ocamlbuild to build, then you need to copy
you include files to \_build if you use relative path in
\textbf{INCLUDE} macro, otherwise you should use absolute path.

 You can predefine some regexps (copied from ocaml source code)
\textit{ parsing/lexer.ml}.
\inputminted{ocaml}{/Users/bobzhang1988/predefine_ulex.ml}


Ulex interface

Roughly equivalent to the module Lexing, except that its lexbuffers
handles Unicode code points\textbf{ OCaml type:int in the range
0.. 0x10ffff} instead of bytes (OCamltype : char).

    You can customize implementation for lex buffers, define a module
L which implements \emph{start,next,mark, and backtrack and the Error
exception}.  They need not work on a type named lexbuf, you can use
the type name you want.  Then, just do in your \emph{ulex-processed}
source, before the first lexer specification\verb|module Ulexing = L|
If you inspect the processed output by camlp4, you can see that the
generated code \emph{introducing Ulexing } very \emph{late} and
actually use very limited functions, other functions are just provided
for your convenience, and it did not have any type annotations, so you
really can customize it. I think probably ocamllex can do the similar
trick.
    
\inputminted{ocaml}{code/ulex_intf.ml}
    
Ulex does not handle line position, you have only global char
position, but we are using emacs, not matter too much

\textbf{Example}

Here is the example of simple basic lexer 
\inputminted{ocaml}{code/basic_ulex.ml}

%%% Local Variables: %%% mode: latex %%% TeX-master: "master" %%% End:
