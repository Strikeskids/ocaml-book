#+OPTIONS: ^:{}



* Implementation

** Cset

   It defines some util functions for =character set= which was
   represented as lists of intervals =(int * int) list=. It defines
   some constants and set operations on =character set=.

** Ulexing

   This module provides runtime support for lexers generated by
   =ulex=.  Roughly equivalent to the module Lexing, except that its
   lexbuffers handles Unicode code points OCaml type =int= in the
   range =0.. 0x10ffff= instead of bytes (OCaml type :char).

   You can customize implementation for lex buffers, define a module L
   which implements /start,next,mark, and backtrack/ and the /Error/
   exception}.  They need not work on a type named lexbuf, you can use
   the type name whatever *you want*.

   Other functions are just provided for your convenience at
   runtime,so you can customize it.

   You can refer module =Custom_lexing= in the source tree for
   detailed example.

   =exception Error= is raised when it can not parse a token from
   the lexbuf.

   =exception InvalidCodepoint of int= is raised when some code
   point is not compatible with a specified encoding.
   
*** roll back

    =Ulexing.rollback lexbuf=, so for string lexing, you can rollback
    one char, and =plugin your string lexer=, but not generally
    usefull, ulex *does not* support shortest mode yet. Sometimes the
    semantics of rolling back is not what you want like recursive
    descent parser.


** Example 

*** Basic 
   #+BEGIN_SRC ocaml
     let regexp op_ar = ['+' '-' '*' '/']
     let regexp op_bool = ['!' '&' '|']
     let regexp rel = ['=' '<' '>']
     (** get string output, not int array *)  
     let lexeme = Ulexing.utf8_lexeme
     let rec basic = lexer
       | [' '] -> basic lexbuf 
       | op_ar | op_bool ->
         let ar = lexeme lexbuf in 
         `Lsymbol ar
       | "<=" | ">="| "<>" | rel -> `Lsymbol (lexeme lexbuf)
       |("REM" | "LET" | "PRINT" | "INPUT" | "IF"| "THEN") ->
         `Lsymbol (lexeme lexbuf)
       | '-'?['0'-'9']+ -> `Lint (int_of_string (lexeme lexbuf))
       | ['A'-'z']+ -> `Lident (lexeme lexbuf)
       | '"' [^ '"'] '"' ->
         `Lstring (let s = lexeme lexbuf in
                   String.sub s 1 (String.length s - 2))
       | eof -> raise End_of_file    
       | _ ->
         (print_endline (lexeme lexbuf ^ "unrecognized");
         basic lexbuf)
     let token_of_string str =
       str
       |> Stream.of_string
       |> Ulexing.from_utf8_stream
       |> basic
     let tokens_of_string str =
       let output = ref [] in
       let lexbuf = str |> Stream.of_string |> Ulexing.from_utf8_stream in
       (try 
         while true do
         let token = basic lexbuf in 
         output:= token :: !output
         done
       with End_of_file -> ());
       List.rev (!output)   
     let _ = tokens_of_string
       "a + b >= 3 > 3 < xx"
   #+END_SRC

*** Other backends
    Notice that =ocamlnet= provides a fast =Ulexing module=, probably
    you can change its interal representation.

    #+BEGIN_SRC ocaml
      open Netulex
      let digits = lexer
         | ['0'-'9']+ -> `Number(int_of_string(Ulexing.utf8_lexeme lexbuf))
         | 8364       -> `Euro_sign   (* Code point #8364 in Unicode *)
      
               
      let sample = "3242543\226\130\172";;
      let ulb = ULB.from_string `Enc_utf8 sample;;
      let lexbuf = Ulexing.from_ulb_lexbuf ulb;;
      let first_token,second_token  = (digits lexbuf,digits lexbuf) ;;
      (* let first_token = digits lexbuf *)
      (* let second_token = digits lexbuf *)
          
      type t = [`Euro_sign | `Number of int]
      
      let string_of_t x =
        match x with
        | `Euro_sign -> "euro"
        | `Number x -> string_of_int x
              
      let _ = begin 
        prerr_endline (string_of_t first_token);
        prerr_endline (string_of_t second_token);
      end
          
    #+END_SRC


* Caution
  When you use ulex to generate the code, make sure to write the
  interface by yourself, the problem is that when you use the default
  interface, it will generate =__table__=, and different file may
  overlap this name, when you open the module, it will cause a disaster,
  so the best to do is *write your .mli* file.

  And when you write lexer, make sure you *complete the default case*,
  check the generated code, otherwise its behavior is weird.

* Vs ocamllex

  Ulex support *unicode*, while ocamllex doesn't, it just scans bytes.
  Ulex does not support *as* syntax as ocamllex.
