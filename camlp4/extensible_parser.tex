\section{Extensible Parser}

Camlp4's extensible parser is deeply combined with its own lexer, use
menhir if it is very complex and not ocaml-oriented. It is very hard
to debug in itself. So I suggest it is used to do simple
ocaml-oriented parsing.

\subsection{Examples}
First example (a simple calculation)


\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/simple_calc.ml}


The tags file is 
\begin{bluetext}
<simple_calc.ml> : pp(camlp4of)
<simple_calc.{cmo,byte,native}> : use_dynlink, use_camlp4_full
\end{bluetext}


For oco in \textbf{ toplevel }, extensible parser works \textbf{ quite
  well in original syntax}, so if you don't do quasiquoation in
toplevel, \textit{feel free to use original syntax}.  

Some keywords for extensible paser


  \begin{ocamlcode}
    EXTEND END  LIST0 LIST1 SEP TRY SELF OPT  FIRST LAST  LEVEL AFTER BEFORE
  \end{ocamlcode}

SELF represents either the \textbf{current level}, \textbf{the next
  level} or the \textbf{ first level} depending on the \textbf{
  associativity} and the \textbf{position} of the SELF in the rule .

The identifier NEXT, which is a call to the next level of the current
entry.

\subsection{Mechanism}
A brief introduction to its mechanism \\
  There are four generally four phases
  \begin{enumerate}[1]
  \item collection of new keywords, and update of the lexer associated
    to the grammar
  \item representation of the grammar as a tree data structure
  \item left-factoring of each precedence level \\
    when there's a common perfix of symblos(a symbol is a keyword,
    token, or entry ), the parser does not branch until the common parser
    has been parsed. \textbf{that's how grammars are implemented, first the
      corresponding tree is generated, then the parser is generated for
      the tree.}
    some tiny bits 
    \begin{enumerate}[(i)]
    \item Greedy first \\
      when one rule is a prefix of another. 
      \textbf{a token or keyword is preferred over
    epsilon, the empty string (this also holds for other ways that a
    grammar can match epsilon )} factoring happens when the parser is
  built .
    \item \textbf{ explicit token or keyword trumps an entry} so you
      have two prductions, with the same prefix, except the last
      one. one is another entry, and the other is a token, \textbf{the
        parser will first try the token, if it succeeds, it stops,
        otherwise they try the entry.} This sounds weird, but it is
      reasonable, after left-factorization, the parser pays no cost
      when it tries just a token, it's amazing that even more tokens,
      the token rule still wins, and \textbf{even the token rule fails
        after consuming some tokens, it can even transfer to the entry
        rule }, local try????? .  \textbf{it seems that after
        factorization, the rule order may be changed }. \\
  \item the data structure representing the grammar is then passed as
    argument to a generic parser
    \end{enumerate}
  \end{enumerate}


It's really hard to understand how it really works. Here are some
experiments I did, but did not know how to explain

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/parser1.ml}
We see that \verb|MGram.Entry.print| is a good utility. 

The processed code is not too indicative, all the dispatch magic
hides in \verb|MGram.extend| function (or |Insert.extend| function)
\textit{camlp4/Camlp4/Struct/Grammar/Insert.ml}

\begin{ocamlcode}
value extend entry (position, rules) =
      let elev = levels_of_rules entry position rules in
      do {
        entry.edesc := Dlevels elev;
        entry.estart :=
          fun lev strm ->
            let f = Parser.start_parser_of_entry entry in
            do { entry.estart := f; f lev strm };
        entry.econtinue :=
          fun lev bp a strm ->
            let f = Parser.continue_parser_of_entry entry in
            do { entry.econtinue := f; f lev bp a strm }
      };
\end{ocamlcode}


Factoring only happens in the same level within a rule.

You can do explicit backtracking by hand (npeek trick)
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/parser2.ml}
  
\begin{enumerate}[(a)]
  \item left factorization \\
    take rules as follows as an example 
    \begin{ocamlcode}
  "method"; "private"; "virtual"; l = label; ":"; t = poly_type
  "method"; "virtual"; "private"; l = label; ":"; t = poly_type
  "method"; "virtual"; l = label; ":"; t = poly_type
  "method"; "private"; l = label; ":"; t = poly_type; "="; e = expr
  "method"; "private"; l = label; sb = fun_binding
  "method"; l = label; ":"; t = poly_type; "="; e = expr
  "method"; l = label; sb = fun_binding
\end{ocamlcode}

The rules are inserted in a tree and the result looks like:
\begin{ocamlcode}
  "method"
     |-- "private"
     |       |-- "virtual"
     |       |       |-- label
     |       |             |-- ":"
     |       |                  |-- poly_type
     |       |-- label
     |             |-- ":"
     |             |    |-- poly_type
     |             |            |-- ":="
     |             |                 |-- expr
     |             |-- fun_binding
     |-- "virtual"
     |       |-- "private"
     |       |       |-- label
     |       |             |-- ":"
     |       |                  |-- poly_type
     |       |-- label
     |             |-- ":"
     |                  |-- poly_type
     |-- label
           |-- ":"
           |    |-- poly_type
           |            |-- "="
           |                 |-- expr
           |-- fun_binding
      
    \end{ocamlcode}

This tree is built as long as rules are inserted.
\item \textbf{start and continue}
  At each entry level, the rules are separated into \textbf{two
    trees}:
  \begin{enumerate}[(a)]
  \item The tree of the rules not starting with neither the current entry name
    nor by ``SELF''(start)
  \item The tree of the rules starting with the current entry or by
    SELF, this symbol \textbf{itself not being included} in the tree
  \end{enumerate}

  They determine two functions :
  \begin{enumerate}
  \item The function named {\color{red} ``start''}, analyzing the first tree
  \item The function named {\color{red} ``continue''}, taking, as parameter, a value
    previously parsed, and analyzing the second tree. 
  \end{enumerate}

  A call to an entry, correspond to a call to the \textbf{``start''} function of
  the \textbf{``first''} level of the entry.

  For the ``start'', it tries its tree, if it works, it calls the
  ``continue'' function of the same level, giving the result of ``start''
  as parameter. If this ``continue'' fails, return itself. (continue may
  do some more interesting stuff). If the ``start'' function fails, the
  ``start'' of the next level is tested until it fails. 


  For the ``continue'', it first tries the ``continue'' function of the
  \textbf{next} level. (here + give into *), if it fails or it's the
  last level, it then tries itself, giving the result as parameter. If
  it still fails, return its extra parameter.

  A special case for rules ending with SELF or the current entry
  name. For this last symbol, there's a call to the ``start'' function
  of \textbf{the current level (RIGHTA) or the next level (OTHERWISE)}

  When a SELF or the current entry name is encountered in the middle
  of the rule, there's a call to the start of the \textbf{first level} of the
  current entry.

  Each entry has a start and continue

\begin{ocamlcode}
(* list of symbols, possible empty *)
LIST0 : LIST0 rule | LIST0 [ <rule definition> -> <action> ]
(* with a separator *)
LIST0 : LIST0 rule SEP <symbol>
| LIST0 [<rule definition > -> <action>] SEP <symbol>
  LIST1 rule
| LIST1 [<rule definition > -> <action > ]
| LIST1 rule SEP <symbol>
| LIST1 [<rule definition > -> <action >] SEP <symbol>
OPT <symbol>
SELF
TRY (* backtracking *)
FIRST LAST LEVEL level, AFTER level, BEFORE level 
\end{ocamlcode}

\end{enumerate}

\subsection{STREAM PARSER}
  \begin{enumerate}[(a)]
  \item stream parser

\begin{alternate}
let rec p = parser [< '"foo"; 'x ; '"bar">] -> x | [< '"baz"; y = p >] -> y;;
val p : string Batteries.Stream.t -> string = <fun>
\end{alternate}

\begin{ocamlcode}
camlp4of  -str "let rec p = parser [< '\"foo\"; 'x ; '\"bar\">] -> x | [< '\"baz\"; y = p >] -> y;;"
(** output 
   normal pattern : first peek, then junk it 
*)
let rec p (__strm : _ Stream.t) =
  match Stream.peek __strm with
  | Some "foo" ->
      (Stream.junk __strm;
       (match Stream.peek __strm with
        | Some x ->
            (Stream.junk __strm;
             (match Stream.peek __strm with
              | Some "bar" -> (Stream.junk __strm; x)
              | _ -> raise (Stream.Error "")))
        | _ -> raise (Stream.Error "")))
  | Some "baz" ->
      (Stream.junk __strm;
       (try p __strm with | Stream.Failure -> raise (Stream.Error "")))
  | _ -> raise Stream.Failure
camlp4of -str "let rec p = parser [< x = q >] -> x | [< '\"bar\">] -> \"bar\""
(** output  *)
let rec p (__strm : _ Stream.t) =
  try q __strm
  with
  | Stream.Failure -> (* limited backtracking *)
      (match Stream.peek __strm with
       | Some "bar" -> (Stream.junk __strm; "bar")
       | _ -> raise Stream.Failure)
\end{ocamlcode}
  \end{enumerate}

\subsection{Grammar}


\begin{ocamlcode}
se (FILTER _* "Exc_located") "Loc" ;;
exception Exc_located of t * exn 
(** an exception containing an exception *)
se (FILTER _* "type" space+ "t") "Loc";; 
type t = Camlp4.PreCast.Loc.t
\end{ocamlcode}

we can re-raise the exception so it gets \textit{printed} using
\textit{Printexc} .

A literal string (like ``foo'') indicates a \textbf{KEYWORD} token ;
using it in a grammar \textbf{registers the keyword} with the lexer. When
it is promoted as a key word, it will no longer be used as a \textbf{
  LIDENT}, so for example, the parser parser, will \textbf{break some valid
programs} before, because \textbf{parser} is now a keyword. This is the
convention, to make things simple, you can find other ways to overcome
the problem, but it's too complicated. you can also say (x= KEYWORD)
or pattern match syntax (`LINDENT x) to get the actual token
constructor. The parser \textbf{ignores} extra tokens after a success.


\begin{enumerate}


\item LEVELS \\ they can be labeled following an entry, like (expr
  LEVEL "mul"). However, explicitly specifying a level when calling an
  entry \verb|might defeats| the start/continue mechanism.
\item NEXT LIST0 SEP OPT TRY \\
  NEXT refers to the entry being defined at the following level
  regardless of assocaitivity or position.
  LIST0 elem SEP sep .
  Both LIST0 and OPT can match the epsilon, but its priority is lower.
  For TRY, non-local backtracking, a Stream.Error will be converted to
  a Stream.Failure.
  \begin{ocamlcode}
    expr : [[ TRY f1 -> "f1" | f2 -> "f2" ]]
  \end{ocamlcode}
  
\item nested rule (only one level )

  \begin{ocamlcode}
    [x = expr ; ["+" | "plus" ]; y = expr -> x + y ]
  \end{ocamlcode}
\item EXTEND is an expression (of type unit) \\
  it can be evaluated at toplevel, but also inside a function, when
  the syntax extension takes place when the function is called.
\item Translated sample code   
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=1,lastline=10]{ocaml}{camlp4/code/extend_trans.ml}
The processed code is as follows:
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=11]{ocaml}{camlp4/code/extend_trans.ml}

        
\item if there are unexpected symbols after a correct expression, the trailing symbols are ignored.

\begin{ocamlcode}
let expr_eoi = Grammar.Entry.mk "expr_eoi" ;;
EXTEND expr_eoi : [[ e = expr ; EOI -> e]]; END ;;
\end{ocamlcode}

The keywords are stored \textbf{ in a hashtbl}, so it can be updated
\verb|dynamically|.

\item level \\
  \begin{bluetext}
  rule ::= list-of-symbols-seperated-by-semicolons -> action 
  level ::=  optional-label optional-associativity
  [list-of-rules-operated-by-bars] 
  entry-extension ::=
  identifier : optional-position  [ list-of-levels-seperated-by-bars ] 
  optional-position ::= FIRST | LAST | BEFORE label | AFTER label |
  LEVEL label  
  \end{bluetext}
\item Grammar modification \\ When you extend an entry, by default
  \textbf{ the first level of the extension extends the first level of
    the entry}

  For example you a grammar like this :
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=1,lastline=36]{ocaml}{camlp4/code/grammar.ml}
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=37,lastline=56]{ocaml}{camlp4/code/grammar.ml}
  This extends the first level ``add''. you can double check by
  printing the result


  When you want to create a new level in the last position 
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=57,lastline=78]{ocaml}{camlp4/code/grammar.ml}


  When you want to insert in the level ``mult'' in the first position 
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=79,lastline=99]{ocaml}{camlp4/code/grammar.ml}
  

  When you want to insert a new level before ``mult'' 
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=100,lastline=123]{ocaml}{camlp4/code/grammar.ml}


\item Grammar example
  You can do some search in the toplevel as follows
\begin{ocamlcode}
se (FILTER _* "val" _* "expr" space+ ":" ) "Syntax" ;;
\end{ocamlcode}

\begin{ocamlcode}  
Gram.Entry.print Format.std_formatter Syntax.expr;;
\end{ocamlcode}

Code listed below  is the expr parse tree
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/expr_parse_tree.ml}


A syntax extension of \verb|let try|
\begin{alternate}
let try a = 3 in true with Not_found -> false || false;;
true  
\end{alternate}

First, it uses start parser to parse \textit{let try a = 3 in true
  with Not\_found -> false}, then it calls the cont parser, and the
next level cont parser, etc, and then it succeeds. This also applies
to ``apply'' level.


A tiny extension(you modify the Camlp4.PreCast.Gram, it will be
reflected on the fly)
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/syntax_extension_a.ml}

\item when two rules overlapping, the EXTEND statement replaces the
    old version by the new one and displays a warning. 

\begin{ocamlcode}
se (FILTER _* "warning") "Syntax"
\end{ocamlcode}
\begin{ocamlcode}
type warning = Loc.t -> string -> unit
val default_warning : warning
val current_warning : warning ref
val print_warning : warning
\end{ocamlcode}
  

\end{enumerate}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
