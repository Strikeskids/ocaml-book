\section{Built in syntax extension in camlp4}


\subsection{Map Filter}
\label{transform}


The filter \emph{Camlp4MapGenerator} reads \emph{OCaml} type
definitions and generate a class that implements a map traversal.  The
generated class have a method per type you can override to implement a
\emph{map traversal}. It needs to read the \verb|definition| of the
type.

Camlp4 uses the \textbf{ filter} iteself to bootstrap.


\begin{ocamlcode}
(** file Camlp4Ast.mlast *)
class map = Camlp4MapGenerator.generated;
class fold = Camlp4FoldGenerator.generated;
\end{ocamlcode}

As above, \verb|Camlp4.PreCast.Ast| has a corresponding map traversal
object, which could be used by you: (the class was generated by our
filter) \verb|Ast.map| is a class
\begin{ocamlcode}
let b = new Camlp4.PreCast.Ast.map ;;
val b : Camlp4.PreCast.Ast.map = <obj>
\end{ocamlcode}

\subsection{Case study-Filter example}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=1,lastline=9]{ocaml}{camlp4/code/ast_add_zero.ml}
you can write it without sytax extension(very tedious),
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=11,lastline=31]{ocaml}{camlp4/code/ast_add_zero.ml}
To make life easier, you can write like this 
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=32,lastline=38]{ocaml}{camlp4/code/ast_add_zero.ml}

In the module \verb|Camlp4.PreCast.AstFilters|, which is generated by
\verb|Camlp4.Struct.AstFilters.Make|, there are some utiliies to do
filter over the ast. It's actually very simple. (\ref{AstFilters})
\begin{ocamlcode}
    type 'a filter = 'a -> 'a
    val register_sig_item_filter : Ast.sig_item filter -> unit
    val register_str_item_filter : Ast.str_item filter -> unit
    val register_topphrase_filter : Ast.str_item filter -> unit
    val fold_interf_filters : ('a -> Ast.sig_item filter -> 'a) -> 'a -> 'a
    val fold_implem_filters : ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
    val fold_topphrase_filters :
      ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
\end{ocamlcode}


You can also generate map traversal for ocaml type. \emph{put your
  type definition before} you macro, like this
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/ast_map.ml}
Without filter, you would write the transformer by hand like this 
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/ast_map_o.ml}

\subsection{Bootstrap}
Camlp4 use the filter in \verb|antiquot_expander|, for example in
\textit{Camlp4Parsers/Camlp4QuotationCommon.ml}, in the definition of
\verb|add_quotation|, we have


\begin{ocamlcode}
value antiquot_expander = object
  inherit Ast.map as super ; (** inherited from Ast.map *)
  method patt : patt -> patt ...
  method expr : expr -> expr ...
let expand_expr loc loc_name_opt s =
  let ast = parse_quot_string entry_eoi loc s in
  let _ = MetaLoc.loc_name.val := loc_name_opt in
  let meta_ast = mexpr loc ast in
  let exp_ast = antiquot_expander#expr meta_ast in
  exp_ast in
\end{ocamlcode}


Notice that it first invoked \verb|parse_quot_string|, then do some
transformation, \textbf{ that's how quotation works} !, it will be
changed to your customized quotation parser, and when it goes to
antiquot syntax, it will go back to \textbf{ host language
  parser}. Since the host language parser also support quotation
syntax (due to \textbf{ reflexivity}), so you \textbf{ nest your
  quotation whatever you want.}

There are other transformers as well.


\subsection{Fold filter}

\begin{ocamlcode}
  class x = Camlp4FoldGenerator.generated ;
\end{ocamlcode}

\subsection{Meta filter}
Meta filter needs a module name, however, it also needs the source of
the definition of the module. (Since OCaml does not have type
reflection). There are some problems here, first you want to separate
the type definition in another file, this could be achieved while
using macro \verb|INCLUDE|, and \verb|Camlp4Trash|, however, you also
want to make your type definition to using another syntax extension,
i.e, \verb|sexplib|, \verb|deriving|, \verb|deriving| will generate a
bunch of modules and types, which conflicts with our
\verb|Meta filter|. So, be careful here.


However, the problem can not be solved for meta filter, it can be
solved for \verb|map, fold| filter, for the meta filter, it will
introduce the name of \verb|Camlp4Trash| into the source, so you can
not really trash the module. The only way to do it is to write your
own \verb|TrashModule| ast filter.

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize]{ocaml}{camlp4/code/jake/json_ast.ml}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize]{ocaml}{camlp4/code/jake/pa_json_ast.ml}
Notice that we have \verb|Camlp4TrashX|, you can not trash it, due to
the fact that the generated code needs it.

\subsection{Lift filter}
These functions are what \emph{Camlp4AstLifter uses} to lift the AST,
and also how \emph{quotations are implemented }
A example of meta filter could be found here .
Here we do a interesting experiment, lift a ast for serveral times

\begin{bluetext}
camlp4o -filter lift -filter lift  test_lift.ml -printer o > test_lift_1.ml
camlp4o -filter lift -filter lift  test_lift_1.ml -printer o > test_lift_2.ml
\end{bluetext}

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize]{ocaml}{camlp4/code/jake/test_lift.ml}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize]{ocaml}{camlp4/code/jake/test_lift_1.ml}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize]{ocaml}{camlp4/code/jake/test_lift_2.ml}


\subsection{Location Strip filter}
Replace location with \verb|Loc.ghost|


Might be useful when you compare two asts? YES!  idea? how to use
lifter at toplevel, how to beautify our code, without the horribling
output? (I mean, the qualified name is horrible, but you can solve it
by open the Module)

\subsection{Camlp4Profiler}
Inserts profiling code


\subsection{Camlp4TrashRemover}
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, lastline=40]{ocaml}{camlp4/code/jake/pa_trashmover.ml}

\subsection{Camlp4ExceptionTracer}



