\section {Rewrite of Jake's blog}

Jake's blog is a very comprehensive tutorial for camlp4 introduction.



\subsection{Part1}
Easy to experiment in the toplevel, using my previous {\bf oco},
\begin{ocamlcode}
open Camlp4.PreCast ;;
let _loc = Loc.ghost ;;
(** 
   blabla...
   An idea, how about writing another pretty printer,
   the printer is awful*)
\end{ocamlcode}

\subsection{Part2}
  Just ast transform, easy to experiment in toplevel as well.
  \inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/jake/part2.ml}

  Anyother way to verify? The output of printers does not seem to
  guarantee its correctness.  When you do antiquotation, in the cases
  of inserting an AST rather than a string, usually you \textit{do
    not} need tags, when you inserting a string, probably you
  \textit{need it.}


\subsection{Part3 : Quotations in Depth}


\begin{ocamlcode}
[`QUOTATION x -> Quotation.expand _loc x Quotation.DynAst.expr_tag ]    
\end{ocamlcode}

The `QUOTATION token contains a record including the body of the
quotation and the \verb|tag|. The record is passed off to the
Quotation module to be expanded. The expander parses the quotation
string starting at some non-terminal(you specified), then runs the
result through the antiquotation expander

\begin{ocamlcode}
  |`ANTIQUOT (``exp'' | ``'' | ``anti'' as n) s ->
  <:expr< $anti:make_anti ~c:"expr" n s $>>
\end{ocamlcode}

The antiquotation creates \verb|a special AST node| to hold the body of the
antiquotation, each type in the AST has a constructor (\verb|ExAnt, TyAnt|,
etc.) \verb|c|  means context here.


Here we grep \verb|Ant|, and the output is as follows
\begin{bluetext}
  27 matches for "Ant" in buffer: Camlp4Ast.partial.ml
      5:    | BAnt of string ]
      9:    | ReAnt of string ]
     13:    | DiAnt of string ]
     17:    | MuAnt of string ]
     21:    | PrAnt of string ]
     25:    | ViAnt of string ]
     29:    | OvAnt of string ]
     33:    | RvAnt of string ]
     37:    | OAnt of string ]
     41:    | LAnt of string ]
     47:    | IdAnt of loc and string (* $s$ *) ]
     87:    | TyAnt of loc and string (* $s$ *)
     93:    | PaAnt of loc and string (* $s$ *)
    124:    | ExAnt of loc and string (* $s$ *)
    202:    | MtAnt of loc and string (* $s$ *) ]
    231:    | SgAnt of loc and string (* $s$ *) ]
    244:    | WcAnt of loc and string (* $s$ *) ]
    251:    | BiAnt of loc and string (* $s$ *) ]
    258:    | RbAnt of loc and string (* $s$ *) ]
    267:    | MbAnt of loc and string (* $s$ *) ]
    274:    | McAnt of loc and string (* $s$ *) ]
    290:    | MeAnt of loc and string (* $s$ *) ]
    321:    | StAnt of loc and string (* $s$ *) ]
    337:    | CtAnt of loc and string ]
    352:    | CgAnt of loc and string (* $s$ *) ]
    372:    | CeAnt of loc and string ]
    391:    | CrAnt of loc and string (* $s$ *) ];
\end{bluetext}




ANTIQUOTATION example 


\begin{alternate}
<:expr< $int: "4"$ >>;;
- : Camlp4.PreCast.Ast.expr = Camlp4.PreCast.Ast.ExInt (<abstr>, "4")
<:expr< $`int: 4$ >>;; (** the same result *)
- : Camlp4.PreCast.Ast.expr = Camlp4.PreCast.Ast.ExInt (<abstr>, "4")
<:expr< $`flo:4.1323243232$ >>;;
- : Camlp4.PreCast.Ast.expr = Camlp4.PreCast.Ast.ExFlo (<abstr>, "4.1323243232")
# <:expr< $flo:"4.1323243232"$ >>;;
- : Camlp4.PreCast.Ast.expr = Camlp4.PreCast.Ast.ExFlo (<abstr>, "4.1323243232")
(** maybe the same for flo *)
\end{alternate}



\begin{bluetext}
    match_case:
      [ [ "["; l = LIST0 match_case0 SEP "|"; "]" -> Ast.mcOr_of_list l
        | p = ipatt; "->"; e = expr -> <:match_case< $p$ -> $e$ >> ] ]
    ;
    match_case0:
      [ [ `ANTIQUOT ("match_case"|"list" as n) s ->
            <:match_case< $anti:mk_anti ~c:"match_case" n s$ >>
        | `ANTIQUOT (""|"anti" as n) s ->
            <:match_case< $anti:mk_anti ~c:"match_case" n s$ >>
        | `ANTIQUOT (""|"anti" as n) s; "->"; e = expr ->
            <:match_case< $anti:mk_anti ~c:"patt" n s$ -> $e$ >>
        | `ANTIQUOT (""|"anti" as n) s; "when"; w = expr; "->"; e = expr ->
            <:match_case< $anti:mk_anti ~c:"patt" n s$ when $w$ -> $e$ >>
        | p = patt_as_patt_opt; w = opt_when_expr; "->"; e = expr -> <:match_case< $p$ when $w$ -> $e$ >>
      ] ]
    \end{bluetext}
    
You can see that \verb|match_case0|, if we use the list antiquotation,
the first case in \verb|match_case0| returns an antiquotation with tag
\verb|listmatch_case|,and we get the following expansion


\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/jake/antiquot_expander.ml}

Here we see the ambiguity of original syntax,

\begin{bluetext}
<< type t = [ $list:List.map (fun c -> <:ctyp< $uid:c$ >>)$]  >>
\end{bluetext}

In original syntax, it does not know it's variant context, or just
type synonm. (you can add a constructor to make it clear)

\subsection{Part4 Parsing Ocaml Itself Using Camlp4}

We have to use revised syntax here, because when using quasiquotation,
it has ambiguity to get the needed part, revised syntax was designed
to reduce the ambiguity. 

The following code is a greate file parsing ocaml itself.
Do not use MakeSyntax below, since it will introduce unnecessary
abstraction type, which makes sharing code very difficult

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/jake/otags.ml}


\begin{ocamlcode}
let sig = 
  let str = eval "module X = Camlp4.PreCast ;;" 
  and _loc = Loc.ghost in 
  Stream.of_string str |> Syntax.parse_interf  _loc ;;

open Camlp4.PreCast.Syntax.Ast

(* output
SgMod (<abstr>, "X",
 MtSig (<abstr>,
  SgSem (<abstr>,
   SgSem (<abstr>,
    SgTyp (<abstr>,
     TyDcl (<abstr>, "camlp4_token", [],
      TyMan (<abstr>,
       TyId (<abstr>,
        IdAcc (<abstr>,
         IdAcc (<abstr>, IdUid (<abstr>, "Camlp4"), IdUid (<abstr>, "Sig")),
         IdLid (<abstr>, "camlp4_token"))),
       TySum (<abstr>,
        TyOr (<abstr>,
         TyOr (<abstr>,
          TyOr (<abstr>,
           TyOr (<abstr>,
            TyOr (<abstr>,
             TyOr (<abstr>,
              TyOr (<abstr>,
               TyOr (<abstr>,
                TyOr (<abstr>,
                 TyOr (<abstr>,
                  TyOr (<abstr>,
                   TyOr (<abstr>,
                    TyOr (<abstr>,
                     TyOr (<abstr>,
                      TyOr (<abstr>,
                       TyOr (<abstr>,
                        TyOr (<abstr>,
                         TyOr (<abstr>,
                          TyOr (<abstr>,
                           TyOr (<abstr>,
                            TyOf (<abstr>,
                             TyId (<abstr>, IdUid (<abstr>, "KEYWORD")),
                             TyId (<abstr>, IdLid (<abstr>, "string"))),
                            TyOf (<abstr>,
                             TyId (<abstr>, IdUid (<abstr>, "SYMBOL")),
                             TyId (<abstr>, IdLid (<abstr>, "string")))),
                           TyOf (<abstr>,
                            TyId (<abstr>, IdUid (<abstr>, "LIDENT")),
                            TyId (<abstr>, IdLid (<abstr>, "string")))),
                          TyOf (<abstr>,
                           TyId (<abstr>, IdUid (<abstr>, "UIDENT")),
                           TyId (<abstr>, IdLid (<abstr>, "string")))),
                         TyOf (<abstr>,
                          TyId (<abstr>, IdUid (<abstr>, "ESCAPED_IDENT")),
                          TyId (<abstr>, IdLid (<abstr>, "string")))),
                        TyOf (<abstr>,
                         TyId (<abstr>, IdUid (<abstr>, "INT")),
                         TyAnd (<abstr>,
                          TyId (<abstr>, IdLid (<abstr>, "int")),
                          TyId (<abstr>, IdLid (<abstr>, "string"))))),
                       TyOf (<abstr>,
                        TyId (<abstr>, IdUid (<abstr>, "INT32")), ...)),
                      ...),
                     ...),
                    ...),
                   ...),
                  ...),
                 ...),
                ...),
               ...),
              ...),
             ...),
            ...),
           ...),
          ...),
         ...))),
      ...)),
    ...),
   ...)))
*)
\end{ocamlcode}


\subsection{Part5 Structure Item Filters}
Because I use revised syntax, and take a reference of the
documenation, my ast filter is much nicer than jaked's.  the
documentation of quasiquotation from the wiki page is quite helpful

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/jake/pa_filter.ml}

For locally used syntax extension, I found write some tiny bits
ocamlbuild code pretty convenient. In \verb|myocamlbuild.ml|, only
needs to append some code like this

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=101,lastline=112]{ocaml}{camlp4/code/jake/myocamlbuild.ml}

The tags file then will be like this 
\begin{bluetext}
<pa_filter.{ml}> : pp(camlp4rf)
<pa_filter.{cmo}> : use_camlp4
<test_filter.ml> : camlp4o, use_filter
\end{bluetext}

Using Register Filter has some limitations, like it first parse the
whole file, and then transform each \verb|structure item| one by one,
so the previously generated code will \verb|not have | an effect on
the later code. This is probably what not you want.


You syntax extension may depends on other modules, make sure your
\verb|pa_xx.cma| contains all the modules statically. You can write a
\verb|pa_xx.mllib|, or link the module to \verb|cma| file by hand.

For instance, you \verb|pa_filter.cma| depends on \verb|Util|, then
you will 

\verb|ocalmc -a pa_filter.cmo util.cmo -o pa_filer.cma|

then you could use \verb|camlp4o -parser pa_filter.cma|, it works.

If you write \verb|pa_xx.mllib| file, it would be something like

\begin{bluetext}
pa_filter
util
\end{bluetext}
If you want to use other libraries to write syntax extension, make
sure you link \textbf{all} libraries, including recursive dependency,
i.e, the require field of batteries.
\begin{bluetext}
ocamlc -a  -I +num -I `ocamlfind query batteries` nums.cma unix.cma
bigarray.cma str.cma batteries.cma pa_filter.cma -o x.cma
\end{bluetext}


You must link all the libraries \textit{recursively}, even you don't
need it at all. This is the defect of the OCaml compiler.
\verb|-linkall| here links submodules, recursive linking needs you say
it clearly,  you can find some  help in the META file.

We can also test our filter seriously as follows 
\verb|camlp4of -parser _build/filter.cmo filter_test.ml -filter lift -printer o |


By the \textbf{lift filter} you can see its \textbf{internal
  representation}, textual code does not gurantee its correctness, but
the AST representation could gurantee its correctness.


Built in filters could be referred in \ref{transform}.


\subsection{Part6 Extensible Parser (moved to extensible parser part)}

\subsection{Part7 Revised Syntax }
  Revised syntax provides more context in the form of extra brackets
  etc. so that antiquotation works more smoothly. Simple ideas, this
  is acutally a part of the job \verb|view patterns|, \verb|F#| makes
  use of view patterns extensively in terms of quotations, can we
  borrow some ideas?


\subsection{Part8, 9 Quotation}
  \begin{enumerate}[(a)]
  \item Quotation module
    \begin{ocamlcode}
      se (FILTER _* "expand_fun") "Quotation";;
    \end{ocamlcode}

    \begin{ocamlcode}
type 'a expand_fun = Ast.loc -> string option -> string -> 'a
val add : string -> 'a DynAst.tag -> 'a expand_fun -> unit
val find : string -> 'a DynAst.tag -> 'a expand_fun      
    \end{ocamlcode}

    Other useful functions 
    \begin{ocamlcode}
type 'a expand_fun = Ast.loc -> string option -> string -> 'a
val add : string -> 'a DynAst.tag -> 'a expand_fun -> unit
val find : string -> 'a DynAst.tag -> 'a expand_fun
val default : string ref  (* default quotations *)
val parse_quotation_result :
      (Ast.loc -> string -> 'a) ->
      Ast.loc -> Camlp4.Sig.quotation -> string -> string -> 'a
val translate : (string -> string) ref
val expand : Ast.loc -> Camlp4.Sig.quotation -> 'a DynAst.tag -> 'a
val dump_file : string option ref
    \end{ocamlcode}

    In previous camlp4, Quotation provides a string to string
    transformation, then it default uses \verb|Syntax.expr| or
    \verb|Syntax.patt| to parse the returned string. following
    drawbacks


    \begin{itemize}
    \item needs a \textbf{more} parsing phase
    \item the resulting string may be syntactically incorrect, difficult
      to \textbf{debug}
    \end{itemize}

\item Quotation Expander 
  When without antiquotaions, a parser is enought, other things are
  quite mechanical

  A comprehensive Example Suppose we have already defined an AST, and
  did the parser, meta part(\ref{transform}).
  The parser part is simple, as follows
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=41,lastline=62]{ocaml}{camlp4/code/jake/json.ml}


Now we do a mechanical installation to get a quotation expander 
All need is as follows:
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=63,lastline=83]{ocaml}{camlp4/code/jake/json.ml}

You could also refactor you code as follows:

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=84,lastline=96]{ocaml}{camlp4/code/jake/json.ml}

So in the toplevel
\begin{ocamlcode}
#directory "/_build";;
#load "json.cmo" ;
open Json;  
(* for Jq_ast module, you can find other ways to work
around this *)
 << [ 3 ,4 ]>>;;
- : Json.Jq_ast.t = Json.Jq_ast.Jq_array [Json.Jq_ast.Jq_number 3.; Json.Jq_ast.Jq_number
4.]
\end{ocamlcode}


To build, just add a plugin to your \verb|myocamlbuild.ml| as follows:

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=117,lastline=133]{ocaml}{camlp4/code/jake/myocamlbuild.ml}


And tags file is as follows
\begin{bluetext}
<test_json.ml> : camlp4o, use_json
<test_json.byte> : pkg_dynlink,use_camlp4
\end{bluetext}


\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, ]{ocaml}{camlp4/code/jake/test_json.ml}
It's quite annoying since our type definition was bundled with
\verb|Camlp4.PreCast|, when linking, we introduce unnecessary
dependency on camlp4. You can find some way to walk around it, but
still anonying.


\item Antiquotation Expander


  The meta filter treat any other constructor \textbf{ending in Ant}
specially.


Instead of handling this way:
\begin{ocamlcode}
  |Jq_Ant(loc,s) -> <:expr< Jq_Ant ($meta_loc loc$, $meta_string s$) >>
\end{ocamlcode}


They have:
\begin{ocamlcode}
  |Jq_Ant(loc,s) -> ExAnt(loc,s) 
\end{ocamlcode}
They translate it directly to ExAnt or PaAnt.

\textbf{Attention! there is no semi or comma required in GLOBAL list,
  GLOBAL: json\_eoi  json ; (just whitespace ) }





\begin{ocamlcode}
let try /(_* Lazy as x) ":" (_* as rest ) / = "ghsoghosghsog ghsohgo"
in (x,rest)
with Match_failure _ -> ("","");;  
\end{ocamlcode}


Notice that 
\verb|Syntax.AntiquotSyntax.(parse_expr,parse_patt)|
\verb|Syntax.(parse_implem, parse_interf)|
provides the parser as a host language. The normal part is as follows:

And also, \verb|Syntax.AntiquotSyntax| only provides
\verb|parse_expr,parse_patt| corresponding to two postions where
quotations happen.


\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, lastline=30]{ocaml}{camlp4/code/jake/json_ant.ml}


Here we define the AST in a special way for the convenience of
inserting code.  The parser is modified:
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=32,lastline=57]{ocaml}{camlp4/code/jake/json_ant.ml}

\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=57,lastline=125]{ocaml}{camlp4/code/jake/json_ant.ml}


\begin{ocamlcode}
#load "json_ant.cmo";;
open Json_ant;;
# let a =  << [true,false]>>;;
val a : Json_ant.Jq_ast.t =
  Json_ant.Jq_ast.Jq_array
   (Json_ant.Jq_ast.Jq_comma (Json_ant.Jq_ast.Jq_bool true,
     Json_ant.Jq_ast.Jq_bool false))
# let b = << [true, $a$, false ]>>;;
val b : Json_ant.Jq_ast.t =
  Json_ant.Jq_ast.Jq_array
   (Json_ant.Jq_ast.Jq_comma
     (Json_ant.Jq_ast.Jq_comma (Json_ant.Jq_ast.Jq_bool true,
       Json_ant.Jq_ast.Jq_array
        (Json_ant.Jq_ast.Jq_comma (Json_ant.Jq_ast.Jq_bool true,
          Json_ant.Jq_ast.Jq_bool false))),
     Json_ant.Jq_ast.Jq_bool false))

# << $ << 1 >> $ >>;;
- : Json_ant.Jq_ast.t = Json_ant.Jq_ast.Jq_number 1.
\end{ocamlcode}


The procedure is as follows:
\begin{ocamlcode}
<< $ << 1 >> $>>  (* parsing (my parser) *)
Jq_Ant(_loc, "<< 1 >> ") (* lifting  (mechnical) *)
Ex_Ant(_loc, "<< 1 >>") (* parsing  (the host parser *)
<:expr< Jq_number 1. >>   (* antiquot_expand (my anti_expander ) *)
<:expr < Jq_number 1. >> 
\end{ocamlcode}

\end{enumerate}


\subsection{Part 10 Lexer }

  This part is deprecated. Camlp4 is not vanilla, it's inappropriate
  for not ocaml-oriented programming, since you have to do too much by
  hand.  Just follow the signature of module type Lexer is enough.
  generally you have to provide module Loc, Token, Filter, Error, and
  mk mk is essential

  \begin{ocamlcode}
val mk : unit -> Loc.t -> char Stream.t -> (Token.t * Loc.t ) Stream.t     
  \end{ocamlcode}

  the verbose part lies in that you have to use the Camlp4.Sig.Loc,
  usually you have to maintain a mutable context, so when you lex a
  token, you can query the context to get Loc.t. you can refer Jake's jq\_lexer.ml
  for more details. How about using lexer, parser all by myself?
  The work need to be done lies in you have to supply a plugin of type
  expand\_fun, which is \\
  \verb|type 'a expand_fun = Ast.loc -> string option -> string -> 'a|
  so if you dont use ocamllexer, why bother the grammar module, just
  use lex yacc will make life easier, and you code will run faster . 

\begin{ocamlcode}
type pos = {
  line : int;
  bol  : int;
  off  : int
};
type t = {
  file_name : string;
  start     : pos;
  stop      : pos;
  ghost     : bool
};
open Camlp4.PreCast 
module Loc = Camlp4.PreCast.Loc 
module Error : sig 
  type t 
  exception E of t 
  val to_string : t -> string 
  val print : Format.formatter -> t -> unit 
end =  struct
  type t = string 
  exception E of string 
  let print = Format.pp_print_string (* weird, need flush *)
  let to_string  x  =  x
end
let _ = 
  let module M = Camlp4.ErrorHandler.Register (Error) in ()
let (|> ) x  f = f x 
module Token : sig 
  module Loc : Camlp4.Sig.Loc 
  type t 
  val to_string : t -> string 
  val print : Format.formatter -> t -> unit 
  val match_keyword : string -> t -> bool 
  val extract_string : t -> string 
  module Filter : sig 
    (* here t refers to the Token.t *)
    type token_filter = (t,Loc.t) Camlp4.Sig.stream_filter 
    type t 
    val mk : (string->bool)-> t 
    val define_filter : t -> (token_filter -> token_filter) -> unit 
    val filter : t -> token_filter 
    val keyword_added : t -> string -> bool -> unit 
    val keyword_removed : t -> string -> unit 
  end
  module Error : Camlp4.Sig.Error  
end = struct 
  (** the token need not to be a variant with arms with KEYWORD
      EOI, etc, although conventional
  *)
  type t = 
    | KEYWORD of string 
    | NUMBER of string 
    | STRING of string 
    | ANTIQUOT of string * string 
    | EOI
  let to_string t = 
    let p = Printf.sprintf in 
    match t with 
      |KEYWORD s -> p "KEYWORD %S" s 
      |NUMBER s -> p "NUMBER %S" s 
      |STRING s -> p "STRING %S" s 
      |ANTIQUOT (n,s) -> p "ANTIQUOT %S: %S" n s 
      |EOI -> p "EOI"
  let print fmt x = x |> to_string |> Format.pp_print_string fmt 
  let match_keyword kwd = function 
    |KEYWORD k when kwd = k -> true 
    |_ -> false 

  let extract_string = function 
    |KEYWORD s | NUMBER s | STRING s -> s 
    |tok -> invalid_arg ("can not extract a string from this token : "
                         ^ to_string tok)

  module Loc = Camlp4.PreCast.Loc 
  module Error = Error 
  module Filter = struct 
    type token_filter = (t * Loc.t ) Stream.t -> (t * Loc.t) Stream.t 

    (** stub out *)    
    (** interesting *)
    type t = unit 

    (** the argument to mk is a function indicating whether 
        a string should be treated as a keyword, and the default 
        lexer uses it to filter the token stream to convert identifiers
        into keywords. if we want our parser to be extensible, we should
        take this into account 
    *)
    let mk _ = ()
    let filter _ x  = x
    let define_filter _ _ = ()
    let keyword_added _ _ _ = ()
    let keyword_removed _ _ = ()
  end 
end 
module L = Ulexing 
INCLUDE "/Users/bob/predefine_ulex.ml" 
(* let rec token  c = lexer  *)
(*   | eof -> EOI  *)
(*   | newline -> token *)
(** TOKEN ERROR LOC 
    mk : unit -> Loc.t -> char Stream.t -> (Token.t * Loc.t) Stream.t

    Loc.of_tuple : 
    string * int * int * int * int * int * int * bool -> 
    Loc.t
*)
    
\end{ocamlcode}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
