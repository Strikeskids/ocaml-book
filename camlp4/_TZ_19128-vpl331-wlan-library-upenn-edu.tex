\documentclass[svgnames,12pt,a4paper]{report}
\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{array}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{wasysym}
\usepackage[online]{suthesis-2e}
\usepackage{todonotes}
\usepackage{caption}
\usepackage{minted}


\usepackage{setspace}

\definecolor{MyDarkBlue}{rgb}{0,0.08,0.45}
\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightlightgray}{rgb}{0.98,0.98,0.98}


%% begin listing configuration 
\lstset{
  basicstyle=\footnotesize\ttfamily,
  numberstyle=\tiny,
  % numbers=left,
  stepnumber=5,
  numbersep=5pt,
  tabsize=2,
  extendedchars=true,
  breaklines=true,
  keywordstyle=\color{blue}\bfseries, % to do
  stringstyle=\color{orange}\ttfamily, %to do
  identifierstyle=\color{teal},
  showstringspaces=true,
  showspaces=false,
  showtabs=false,
  % xleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  % backgroundcolor=\color{lightgray}, % to do
  commentstyle=\color{red},% todo 
  % frame=lines,
  frame=bottom,
  backgroundcolor=\color{lightlightgray},
  framerule=1pt,
  % emph={square,root},
  % emphstyle=\underbar,
  %% language={[Objective]Caml},
}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

%% end


\makeatletter

\makeatother


% \newenvironment{bluecode}{\Verbatim[fomartcom=\color{blue}]}{\endVerbatim}
% New commands serve as shorthand for frequently used command combinations.
% \newcommand{\ind}[1]{\mathbf{1}\left(#1\right)}
% \newcommand{\bx}{\mathbf{x}}
% \newcommand{\E}{\mathbf{E}}
% \DefineVerbatimEnvironment{redcode}{Verbatim}{formatcom=\color{red},fontsize=\scriptsize}
% \DefineVerbatimEnvironment{bluetext}{Verbatim}{formatcom=\color{MyDarkBlue},fontsize=\scriptsize}
% \DefineVerbatimEnvironment{bluecode}{Verbatim}{formatcom=\color{blue},fontsize=\scriptsize}
% \lstnewenvironment{redcode}
% {\singlespacing}{}

\newcommand{\ChangeLine}[1]{%
\ifodd\value{FancyVerbLine}%
\textcolor{red}{#1}\else\textcolor{blue}{#1}\fi}

\newminted[redcode]{ocaml}{
}

\newminted[bluecode]{ocaml}{
}

\newminted[smallcode]{ocaml}{
 }

\newminted[alternatecode]{ocaml}{frame=single,
 formatcom=\renewcommand{\FancyVerbFormatLine}{\ChangeLine}}


\lstnewenvironment{bluetext}
{\singlespacing\lstset{backgroundcolor=\color{lightgray}}}{}

\DefineVerbatimEnvironment{alternate}{Verbatim}%
{formatcom=\renewcommand{\FancyVerbFormatLine}{\ChangeLine},%
fontsize=\scriptsize,frame=lines}{}

% \def\dashfill{\cleaders\hbox{-}\hfill}

\begin{document}
\section{Basics Command Lines}


\begin{alternate}
bash-3.2$ camlp4 -where
/Users/bob/SourceCode/ML/godi/lib/ocaml/std-lib/camlp4
bash-3.2$ which camlp4
/Users/bob/SourceCode/ML/godi/bin/camlp4
\end{alternate}


You can grep all executables relevant to camlp4 using a one-line bash
as follows:
\begin{bluetext}
find $(dirname $(which ocaml)) -type f -perm -og+rx | grep camlp4 |
while read ss ; do echo $(basename $ss) ; done
\end{bluetext}

\begin{bluetext}  
camlp4
camlp4boot
camlp4o
camlp4o.opt
camlp4of
camlp4of.opt
camlp4oof
camlp4oof.opt
camlp4orf
camlp4orf.opt
camlp4prof
camlp4r
camlp4r.opt
camlp4rf
camlp4rf.opt
mkcamlp4
safe_camlp4
\end{bluetext}

So the tools at hand are \textbf{camlp4, camlp4o, camlp4of, camlp4oof,
  camlp4orf, camlp4r, camlp4rf }

\begin{bluetext}
camlp4 -h

Usage: camlp4 [load-options] [--] [other-options]
Options:
<file>.ml        Parse this implementation file
<file>.mli       Parse this interface file
<file>.(cmo|cma) Load this module inside the Camlp4 core
  -I <directory>   Add directory in search patch for object files.
  -where           Print camlp4 library directory and exit.
  -nolib           No automatic search for object files in library directory.
  -intf <file>     Parse <file> as an interface, whatever its extension.
  -impl <file>     Parse <file> as an implementation, whatever its extension.
  -str <string>    Parse <string> as an implementation.
  -unsafe          Generate unsafe accesses to array and strings.
  -noassert        Obsolete, do not use this option.
  -verbose         More verbose in parsing errors.
  -loc <name>      Name of the location variable (default: _loc).
  -QD <file>       Dump quotation expander result in case of syntax error.
  -o <file>        Output on <file> instead of standard output.
  -v               Print Camlp4 version and exit.
  -version         Print Camlp4 version number and exit.
  -vnum            Print Camlp4 version number and exit.
  -no_quot         Don't parse quotations, allowing to use, e.g. "<:>" as token.
  -loaded-modules  Print the list of loaded modules.
  -parser <name>   Load the parser Camlp4Parsers/<name>.cm(o|a|xs)
  -printer <name>  Load the printer Camlp4Printers/<name>.cm(o|a|xs)
  -filter <name>   Load the filter Camlp4Filters/<name>.cm(o|a|xs)
  -ignore          ignore the next argument
  --               Deprecated, does nothing    
\end{bluetext}

Useful options 

\verb|-str|

\verb|-loaded-modules|

\verb|-parser <name>| load the parser \textit{Camlp4Parsers/<name>.cm(o|a|xs)}


\verb|-printer <name>| load the printer
\textit{Camlp4Printerss/<name>.cm(o|a|xs)}

\verb|-filter <name>| load the filter 
\textit{Camlp4Filters/<name>.cm(o|a|xs).}


\verb|-printer o| means print in original syntax. 


These command lineoptions are all handled in \emph|Camlp4Bin.ml |

\verb|Camlp4o -h| 
There are options added by loaded object files


\verb| -add_locations| Add locations as comment


\verb| -no_comments|


\verb| -curry-constr |


\verb| -sep | Use this string between parsers 


That reflective is true means when extending the syntax of the host
language will \textbf{ also extend the embedded one}


  \begin{tabular}{|c|c|c|c|c|}
    \hline
                      & host     & embedded & reflective & 3.09 equivalent     \\
    camlp4of          & original & original & Yes        & N/A                 \\
    camlp4rf          & revised  & revised  & Yes        & N/A                 \\
    camlp4r-parser rq & revised  & revised  & No         & camlp4r q\_MLast.cmo \\
    camlp4orf         & original & revised  & No         & camlp4o q\_MLast.cmo \\
    camlp4oof         & original & original & No         & N/A                 \\
    \hline
  \end{tabular} \\
  
Camlp4r
    \begin{enumerate}
    \item parser \\
      RP, RPP(RevisedParserParser)
    \item printer \\
      OCaml
    \end{enumerate}


Camlp4rf (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      RP,RPP, GrammarP, ListComprehension, MacroP, QuotationExpander
    \item printer \\
      OCaml
    \end{enumerate}


Camlp4o (extended from camlp4r)

    \begin{enumerate}
    \item parser \\
      OP, OPP, RP,RPP
    \end{enumerate}

Camlp4of (extended from camlp4o)


    \begin{enumerate}
    \item parser \\
      GrammarParser, ListComprehension, MacroP, QuotatuinExpander
    \item printer 
    \end{enumerate}


Without ocamlbuild, ocamlfind, a simple build would be like this 


\verb|ocamlc -pp camlp4o.opt error.ml|
  

\begin{alternate}
camlp4of -str "let a = [x| x <- [1.. 10] ] " 
let a = [ 1..10 ]
camlp4o -str 'true && false'
true && false
\end{alternate}


\begin{redcode}
camlp4of -str "let q = <:str_item< let f x = x >>"

let q =
  Ast.StSem (_loc,
    (Ast.StVal (_loc, Ast.ReNil,
       (Ast.BiEq (_loc,
          (Ast.PaId (_loc, (Ast.IdLid (_loc, "f")))),
          (Ast.ExFun (_loc,
             (Ast.McArr
                (_loc,
                (Ast.PaId (_loc, (Ast.IdLid (_loc, "x")))),
                (Ast.ExNil _loc), (Ast.ExId (_loc, (Ast.IdLid (_loc, "x")))))))))))),
    (Ast.StNil _loc))
\end{redcode}

Now we begin to explore the structure of camlp4 Source Code 

First let's have a look at the directory structure of camlp4 directory.

\begin{bluetext}
|<.>
|--<boot>
|--<build>
|--<Camlp4>
|----<Printers>
|----<Struct>       -- important
|------<Grammar> 
|--<Camlp4Filters>  -- important 
|--<Camlp4Parsers>  -- important 
|--<Camlp4Printers> 
|--<Camlp4Top>
|--<examples>       -- important
|--<man>
|--<test>
|----<fixtures>
|--<unmaintained>   -- many useful extensions unmatained
|----<compile>
|----<etc>
|----<extfold>      -- fold extension 
|----<format>
|----<lefteval>
|----<lib>
|----<ocamllex>
|----<ocpp>
|----<odyl>
|----<olabl>
|----<scheme>
|----<sml>
\end{bluetext}



\verb|Camlp4.PreCast (Camlp4/PreCast.ml)|

Struct directory has module \textit{Loc, Dynloader Functor,
  Camlp4Ast.Make, Token.Make, Lexer.Make, Grammar.Static.Make,
  Quotation.Make}

Camlp4.PreCast \textbf{re-export} such files

    \begin{bluetext}
    Struct/Loc.ml 
    Struct/Camlp4Ast.mlast 
    Struct/Token.ml 
    Struct/Grammar/Parser.ml 
    Struct/Grammar/Static.ml 
    Struct/Lexer.mll 
    Struct/DynLoader.ml 
    Struct/Quotation.ml 
    Struct/AstFilters.ml 
    OCamlInitSyntax.ml 
    Printers/OCaml.ml 
    Printers/OCamlr.ml
    Printers/Null.ml 
    Printers/DumpCamlp4Ast.ml
    Printers/DumpOCamlAst.ml 
    \end{bluetext}


\inputminted{ocaml}{camlp4/code/PreCast_OCamlInitSyntax.ml}


Notice \verb|Gram.Entry| is \textbf{ dynamic, extensible}


\verb|Camlp4.Sig.ml| All are signatures, there's even no
\verb|Camlp4.Sig.mli|

\verb|Camlp4.Struct.Camlp4Ast.mlast| This file use macro
\verb|INCLUDE| to include \verb|Camlp4.Camlp4Ast.parital.ml| for
reuse.
    

\begin{bluecode}
(** file Camlp4Ast.mlast 
  in the file we have *)
Camlp4.Struct.Camlp4Ast.Make : Loc -> Sig.Camlp4Syntax
  module Ast = struct
     include Sig.MakeCamlp4Ast Loc 
  end ;
\end{bluecode}

It uses the \textbf{ filter} iteself to bootstrap.

\begin{bluecode}
(** file Camlp4Ast.mlast *)
class map = Camlp4MapGenerator.generated;
class fold = Camlp4FoldGenerator.generated;
\end{bluecode}


The filter \emph{Camlp4MapGenerator} reads \emph{OCaml} type
definitions and generate a class that implements a map traversal.  The
generated class have a method per type you can override to implement a
\emph{map traversal}.

As follows, \verb|Camlp4.Ast| has a corresponding map traversal
object, which could be used by you: (the class was generated by our
filter)


You can inspect what modules you have loaded in toplevel
\begin{bluecode}
Camlp4.Register.loaded_modules;;
- : string list ref =
{Pervasives.contents =
  ["Camlp4GrammarParser"; "Camlp4OCamlParserParser";
   "Camlp4OCamlRevisedParserParser"; "Camlp4OCamlParser";
   "Camlp4OCamlRevisedParser"]}
\end{bluecode}


\inputminted[firstline=1,lastline=9]{ocaml}{camlp4/code/ast_add_zero.ml}
you can write it without sytax extension(very tedious),
\inputminted[firstline=11,lastline=31]{ocaml}{camlp4/code/ast_add_zero.ml}
To make life easier, you can write like this 
\inputminted[firstline=32,lastline=38]{ocaml}{camlp4/code/ast_add_zero.ml}


In the module 
\begin{bluecode}
open Camlp4.PreCast
\end{bluecode}


You can also generate map traversal for ocaml type. \emph{put your
  type definition before} you macro, like this


\begin{bluecode}
type t1 = ...
and t2 = ...
and tn = ... ;
class map = Camlp4MapGenerator.generated;
\end{bluecode}


\begin{bluetext}
tags : "map_filter_r.ml" : pp(camlp4r -filter map)
\end{bluetext}

\begin{bluetext}
cat map_filter_r.ml
\end{bluetext}

\begin{bluecode}
type a = [A of b | C ]
and b = [B of a | D ]; 
class map = Camlp4MapGenerator.generated;
(* output 
type a = [ A of b | C ] and b = [ B of a | D ];
class map =
  object ((o : 'self_type))
    method b : b -> b = fun [ B _x -> let _x = o#a _x in B _x | D -> D ];
    method a : a -> a = fun [ A _x -> let _x = o#b _x in A _x | C -> C ];
    method unknown : ! 'a. 'a -> 'a = fun x -> x;
  end;
*)
\end{bluecode}

\begin{bluetext}
cat _build/map_filter_r.inferred.mli 
\end{bluetext}

\begin{bluecode}
type a = A of b | C
and b = B of a | D
class map :
  object method a : a -> a method b : b -> b method unknown : 'a -> 'a end
\end{bluecode}

Camlp4 use the filter in \verb|antiquot_expander|, for example in
Camlp4Parsers/Camlp4QuotationCommon.ml, in the definition of
\verb|add_quotation|, we have


\begin{bluecode}
value antiquot_expander = object
  inherit Ast.map as super ;
  method patt : patt -> patt ...
  method expr : expr -> expr ...
let expand_expr loc loc_name_opt s =
  let ast = parse_quot_string entry_eoi loc s in
  let () = MetaLoc.loc_name.val := loc_name_opt in
  let meta_ast = mexpr loc ast in
  let exp_ast = antiquot_expander#expr meta_ast in
  exp_ast in
\end{bluecode}


Notice that it first invoked \verb|parse_quot_string|, then do some
transformation, \textbf{ that's how quotation works} !, it will change
to your customized quotation parser, and when it goes to antiquot
syntax, it will go back to \textbf{ host language parser}. Since the
host language parser also support quotation syntax (due to \textbf{
reflexivity}), so you \textbf{ nest your quotation whatever you
  want.}









%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 

\end{document}
