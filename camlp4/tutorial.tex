\section{Basics Structure}


\begin{alternate}
bash-3.2$ camlp4 -where
/Users/bob/SourceCode/ML/godi/lib/ocaml/std-lib/camlp4
bash-3.2$ which camlp4
/Users/bob/SourceCode/ML/godi/bin/camlp4
\end{alternate}


You can grep all executables relevant to camlp4 using a one-line bash
as follows:
\begin{bluetext}
find $(dirname $(which ocaml)) -type f -perm -og+rx | grep camlp4 |
while read ss ; do echo $(basename $ss) ; done
\end{bluetext}

\begin{bluetext}  
camlp4
camlp4boot
camlp4o
camlp4o.opt
camlp4of
camlp4of.opt
camlp4oof
camlp4oof.opt
camlp4orf
camlp4orf.opt
camlp4prof
camlp4r
camlp4r.opt
camlp4rf
camlp4rf.opt
mkcamlp4
safe_camlp4
\end{bluetext}

So the tools at hand are \textbf{camlp4, camlp4o, camlp4of, camlp4oof,
  camlp4orf, camlp4r, camlp4rf }

\begin{bluetext}
camlp4 -h

Usage: camlp4 [load-options] [--] [other-options]
Options:
<file>.ml        Parse this implementation file
<file>.mli       Parse this interface file
<file>.(cmo|cma) Load this module inside the Camlp4 core
  -I <directory>   Add directory in search patch for object files.
  -where           Print camlp4 library directory and exit.
  -nolib           No automatic search for object files in library directory.
  -intf <file>     Parse <file> as an interface, whatever its extension.
  -impl <file>     Parse <file> as an implementation, whatever its extension.
  -str <string>    Parse <string> as an implementation.
  -unsafe          Generate unsafe accesses to array and strings.
  -noassert        Obsolete, do not use this option.
  -verbose         More verbose in parsing errors.
  -loc <name>      Name of the location variable (default: _loc).
  -QD <file>       Dump quotation expander result in case of syntax error.
  -o <file>        Output on <file> instead of standard output.
  -v               Print Camlp4 version and exit.
  -version         Print Camlp4 version number and exit.
  -vnum            Print Camlp4 version number and exit.
  -no_quot         Don't parse quotations, allowing to use, e.g. "<:>" as token.
  -loaded-modules  Print the list of loaded modules.
  -parser <name>   Load the parser Camlp4Parsers/<name>.cm(o|a|xs)
  -printer <name>  Load the printer Camlp4Printers/<name>.cm(o|a|xs)
  -filter <name>   Load the filter Camlp4Filters/<name>.cm(o|a|xs)
  -ignore          ignore the next argument
  --               Deprecated, does nothing    
\end{bluetext}

Useful options 

\verb|-str|

\verb|-loaded-modules|

\verb|-parser <name>| load the parser \textit{Camlp4Parsers/<name>.cm(o|a|xs)}


\verb|-printer <name>| load the printer
\textit{Camlp4Printerss/<name>.cm(o|a|xs)}

\verb|-filter <name>| load the filter 
\textit{Camlp4Filters/<name>.cm(o|a|xs).}


\verb|-printer o| means print in original syntax. 


These command lineoptions are all handled in \emph|Camlp4Bin.ml |

\verb|Camlp4o -h| 
There are options added by loaded object files


\verb| -add_locations| Add locations as comment


\verb| -no_comments|


\verb| -curry-constr |


\verb| -sep | Use this string between parsers 


That reflective is true means when extending the syntax of the host
language will \textbf{ also extend the embedded one}


  \begin{tabular}{|c|c|c|c|c|}
    \hline
                      & host     & embedded & reflective & 3.09 equivalent     \\
    camlp4of          & original & original & Yes        & N/A                 \\
    camlp4rf          & revised  & revised  & Yes        & N/A                 \\
    camlp4r-parser rq & revised  & revised  & No         & camlp4r q\_MLast.cmo \\
    camlp4orf         & original & revised  & No         & camlp4o q\_MLast.cmo \\
    camlp4oof         & original & original & No         & N/A                 \\
    \hline
  \end{tabular} \\
  
Camlp4r
    \begin{enumerate}
    \item parser \\
      RP, RPP(RevisedParserParser)
    \item printer \\
      OCaml
    \end{enumerate}


Camlp4rf (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      RP,RPP, GrammarP, ListComprehension, MacroP, QuotationExpander
    \item printer \\
      OCaml
    \end{enumerate}


Camlp4o (extended from camlp4r)

    \begin{enumerate}
    \item parser \\
      OP, OPP, RP,RPP
    \end{enumerate}

Camlp4of (extended from camlp4o)


    \begin{enumerate}
    \item parser \\
      GrammarParser, ListComprehension, MacroP, QuotatuinExpander
    \item printer 
    \end{enumerate}


Without ocamlbuild, ocamlfind, a simple build would be like this 


\verb|ocamlc -pp camlp4o.opt error.ml|
  

\begin{alternate}
camlp4of -str "let a = [x| x <- [1.. 10] ] " 
let a = [ 1..10 ]
camlp4o -str 'true && false'
true && false
\end{alternate}


\begin{ocamlcode}
(** camlp4of -str "let q = <:str_item< let f x = x >>"*)
let q =
  Ast.StSem (_loc,
    (Ast.StVal (_loc, Ast.ReNil,
       (Ast.BiEq (_loc,
          (Ast.PaId (_loc, (Ast.IdLid (_loc, "f")))),
          (Ast.ExFun (_loc,
             (Ast.McArr
                (_loc,
                (Ast.PaId (_loc, (Ast.IdLid (_loc, "x")))),
                (Ast.ExNil _loc), (Ast.ExId (_loc, (Ast.IdLid (_loc, "x")))))))))))),
    (Ast.StNil _loc))
\end{ocamlcode}
\verb|camlp4of -p r -str 'you code'| is a good way to learn the
corresponding revised syntax.

You can also customize you options in your filter 
\inputminted[fontsize=\scriptsize, fontsize=\scriptsize, firstline=19,lastline=26]{ocaml}{camlp4/examples/pa_abstract.ml}


Now we begin to explore the structure of camlp4 Source Code 

First let's have a look at the directory structure of camlp4 directory.
\begin{bluetext}
|<.>
|--<boot>
|--<build>
|--<Camlp4>
|----<Printers>
|----<Struct>       -- important
|------<Grammar> 
|--<Camlp4Filters>  -- important 
|--<Camlp4Parsers>  -- important 
|--<Camlp4Printers> 
|--<Camlp4Top>
|--<examples>       -- important
|--<man>
|--<test>
|----<fixtures>
|--<unmaintained>   -- many useful extensions unmatained
|----<compile>
|----<etc>
|----<extfold>      -- fold extension 
|----<format>
|----<lefteval>
|----<lib>
|----<ocamllex>
|----<ocpp>
|----<odyl>
|----<olabl>
|----<scheme>
|----<sml>
\end{bluetext}



\verb|Camlp4.PreCast (Camlp4/PreCast.ml)|

Struct directory has module \textit{Loc, Dynloader Functor,
  Camlp4Ast.Make, Token.Make, Lexer.Make, Grammar.Static.Make,
  Quotation.Make}

Camlp4.PreCast \textbf{re-export} such files

    \begin{bluetext}
    Struct/Loc.ml 
    Struct/Camlp4Ast.mlast 
    Struct/Token.ml 
    Struct/Grammar/Parser.ml 
    Struct/Grammar/Static.ml 
    Struct/Lexer.mll 
    Struct/DynLoader.ml 
    Struct/Quotation.ml 
    Struct/AstFilters.ml 
    OCamlInitSyntax.ml 
    Printers/OCaml.ml 
    Printers/OCamlr.ml
    Printers/Null.ml 
    Printers/DumpCamlp4Ast.ml
    Printers/DumpOCamlAst.ml 
    \end{bluetext}


\inputminted[fontsize=\scriptsize, 
             lastline=55]{ocaml}{camlp4/code/PreCast_OCamlInitSyntax.ml}


If we want to define our special syntax, we could do it like this 
\inputminted[fontsize=\scriptsize,]{ocaml}{camlp4/code/my_own_syntax.ml}


Here we see we could get any parser, any printer we want, very convenient.
Notice \verb|Gram.Entry| is \textbf{ dynamic, extensible}

\inputminted[fontsize=\scriptsize,
             firstline=55]{ocaml}{camlp4/code/PreCast_OCamlInitSyntax.ml}
\verb|OCamlInitSyntax| does not do too many things, first, it
initialize all the entries needed later (they are all blank, to be
extended by your functor), after initialization, it created a
submodule \verb|AntiquotSyntax|, and initialize two entries
\verb|antiquot_expr| and \verb|antiquot_patt|, very easy. 

\verb|Camlp4.Sig.ml| All are signatures, there's even no
\verb|Camlp4.Sig.mli|.

\verb|Camlp4.Struct.Camlp4Ast.mlast| This file use macro
\verb|INCLUDE| to include \verb|Camlp4.Camlp4Ast.parital.ml| for
reuse.
    
Notice an interesting module \verb|AstFilters|, is defined by 

\verb|Struct.AstFilters.Make|
It's very simply actually.
\label{AstFilters}
\inputminted[fontsize=\scriptsize,]{ocaml}{camlp4/code/AstFilters.ml}



\begin{ocamlcode}
(** file Camlp4Ast.mlast 
  in the file we have *)
Camlp4.Struct.Camlp4Ast.Make : Loc -> Sig.Camlp4Syntax
  module Ast = struct
     include Sig.MakeCamlp4Ast Loc 
  end ;
\end{ocamlcode}


Let's see what's in \verb|Register| module
\inputminted[fontsize=\scriptsize,
            ]{ocaml}{camlp4/code/Register.ml}


Notice that functors Plugin, SyntaxExtension, OCamlSyntaxExtension,
OCamlSyntaxExtension, SyntaxPlugin, they did the same thing
essentially, they apply the second Funtor to Syntax(Camlp4.PreCast.Syntax).

Functors Printer, OCamlPrinter, OCamlPrinter, they did the same thing,
apply the Make to Syntax, then register it. 

Functor Parser, OCamlParser, did the same thing. 

Functor AstFilter  did nothing interesting.

it sticks to the toplevel 

\inputminted[fontsize=\scriptsize,
             firstline=123,
             lastline=126,
            ]{ocaml}{camlp4/code/Register.ml}.

It mainly hook some global variables, like
\verb|Camlp4.Register.loaded_modlules|, but there's no fresh meat in
this file.
To conclude, Register did nothing, except making your code more
modular, or register your syntax extension.

As we said, another utility, you can inspect what modules you have
loaded in toplevel:
\begin{ocamlcode}
Camlp4.Register.loaded_modules;;
- : string list ref =
{Pervasives.contents =
  ["Camlp4GrammarParser"; "Camlp4OCamlParserParser";
   "Camlp4OCamlRevisedParserParser"; "Camlp4OCamlParser";
   "Camlp4OCamlRevisedParser"]}
\end{ocamlcode}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 

