\section{Basics Structure}

\subsection{Experimentation Environment}

On Toplevel  you can load camlp4 via  findlib as follows:

\begin{ocamlcode}
#camlp4r;
#load "camlp4rf.cma"
\end{ocamlcode}
Using \verb|ocamlobjinfo| to search modules [\ref{Camlp4 Modules}]:     

\begin{bashcode}
ocamlobjinfo `camlp4 -where`/camlp4fulllib.cma | grep -i unit
\end{bashcode}

\begin{bluetext}
 Camlp4_import Camlp4_config Camlp4 Camlp4AstLoader Camlp4DebugParser
 Camlp4GrammarParser Camlp4ListComprehension Camlp4MacroParser
 Camlp4OCamlParser Camlp4OCamlRevisedParser Camlp4QuotationCommon
 Camlp4OCamlOriginalQuotationExpander Camlp4OCamlRevisedParserParser
 Camlp4OCamlParserParser Camlp4OCamlRevisedQuotationExpander
 Camlp4QuotationExpander Camlp4AstDumper Camlp4AutoPrinter
 Camlp4NullDumper Camlp4OCamlAstDumper Camlp4OCamlPrinter
 Camlp4OCamlRevisedPrinter Camlp4AstLifter Camlp4ExceptionTracer
 Camlp4FoldGenerator Camlp4LocationStripper Camlp4MapGenerator
 Camlp4MetaGenerator Camlp4Profiler Camlp4TrashRemover Camlp4Top
\end{bluetext}
\captionof{listing}{Camlp4 Modules\label{Camlp4 Modules}}

Using script (oco [\ref{lst:oco}] with original syntax is ok), but
when using ocr [\ref{lst:ocr} ] with revised syntax, it will have
some problems, i.e. .ocamlinit, and other startup files including
findlib, so you'd better \textit{not use} revised syntax in the
toplevel. here I use .ocamlinitr (revised syntax) for ocr, but it
still have some problem with findlib, which I think is internal, hard
to solve, but it does not really matter.


Another way to solve this problem is to \textit{customize your toplevel}.

\begin{bashcode}
bash-3.2$ cat /usr/local/bin/oco
ledit -x -h ~/.ocaml_history ocaml dynlink.cma camlp4of.cma -warn-error +a-4-6-27..29
\end{bashcode}
% $
\captionof{listing}{oco\label{lst:oco}}


\begin{bashcode}
bash-3.2$ cat `which ocr`
ledit -x -h ~/.ocaml_history ocaml dynlink.cma camlp4rf.cma -init ~/.ocamlinitr -warn-error +a-4-6-27..29
\end{bashcode}
% $
\captionof{listing}{ocr\label{lst:ocr}}
Customize toplevel has some benefit, linking without scripts make you
more roubst against \textit{.ocamlinit}, we can customize \textit{or}, and
create a script \textit{orr} in the shell.

\begin{ocamlcode}
  ocamlmktop -custom -o oraml -I +camlp4 dynlink.cma camlp4rf.cma \
  str.cma bigarray.cma unix.cma nums.cma -I `ocamlfind query
  batteries` batteries.cma
\end{ocamlcode}
\captionof{listing}{Customized toplevel with revised
  syntax \label{Customized toplevelr}}

\begin{bashcode}
#! /usr/bin/env bash
oraml -init ~/.or  
\end{bashcode}
\captionof{listing}{oramll \label{Oramll}}

You can also have a try like this
\begin{ocamlcode}
open Camlp4.PreCast ;;
let _loc = Loc.ghost ;;
(** 
   blabla...
   An idea, how about installing another pretty printer,
   the printer is awful, actually we have a printer already *)
\end{ocamlcode}

Here are some experiments readers can have a try

\inputminted[fontsize=\scriptsize,bgcolor=lightlightgray]{ocaml}{code/camlp4/experiment/part2.ml}
\captionof{listing}{Play with camlp4 AST \label{Play With Camlp4 AST }}

When you do antiquotation, in the cases of inserting an AST rather
than a string, usually you \textit{do not} need tags, when you
want to interpret a string as a piece of ast, probably you \textit{need it.}
  
\subsection{Command Options}

\begin{bashcode}
bash-3.2$ camlp4 -where
/Users/bob/SourceCode/ML/godi/lib/ocaml/std-lib/camlp4
bash-3.2$ which camlp4
/Users/bob/SourceCode/ML/godi/bin/camlp4
\end{bashcode}


You can grep all executables [\ref{List of camlp4 exectuables}]
relevant to camlp4 using a one-line bash as follows:
\begin{bashcode}
find $(dirname $(which ocaml)) -type f -perm -og+rx | grep camlp4 |
while read ss ; do echo $(basename $ss) ; done
\end{bashcode}

\begin{bluetext}  
camlp4 camlp4boot camlp4o camlp4o.opt camlp4of camlp4of.opt camlp4oof
camlp4oof.opt camlp4orf camlp4orf.opt camlp4prof camlp4r camlp4r.opt
camlp4rf camlp4rf.opt mkcamlp4 safe_camlp4
\end{bluetext}
\captionof{listing}{List of camlp4 executables \label{List of camlp4 executables}}

So the tools at hand are \textit{camlp4, camlp4o, camlp4of, camlp4oof,
  camlp4orf, camlp4r, camlp4rf }

You can type \textit{camlp4 -h } to enumerate all the command line
options. Some pretty useful options are: 

\verb|-str|

\verb|-loaded-modules|

\verb|-parser <name>| load the parser \textit{Camlp4Parsers/<name>.cm(o|a|xs)}


\verb|-printer <name>| load the printer
\textit{Camlp4Printerss/<name>.cm(o|a|xs)}

\verb|-filter <name>| load the filter 
\textit{Camlp4Filters/<name>.cm(o|a|xs).}


\verb|-printer o| means print in original syntax. 


These command line options are all handled in \emph{Camlp4Bin.ml}

\verb|Camlp4o -h| There are options added by loaded object files. You
can added by \verb|Options.add| as well.


\verb| -add_locations| Add locations as comment


\verb| -no_comments|


\verb| -curry-constr |


\verb| -sep | Use this string between parsers 




\subsection{Module Components}

\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
                      & host     & embedded & reflective & 3.09 equivalent     \\
    camlp4of          & original & original & Yes        & N/A                 \\
    camlp4rf          & revised  & revised  & Yes        & N/A                 \\
    camlp4r-parser rq & revised  & revised  & No         & camlp4r q\_MLast.cmo \\
    camlp4orf         & original & revised  & No         & camlp4o q\_MLast.cmo \\
    camlp4oof         & original & original & No         & N/A                 \\
    \hline
  \end{tabular}
  \caption{Module Components}
  \label{tab:camlp4_module_components}
\end{table}

Table \ref{tab:camlp4_module_components} list all components in camlp4
modules. That reflective is true means when extending the syntax of the
host language will \textbf{ also extend the embedded one}

\begin{itemize}  
\item Camlp4r
    \begin{enumerate}
    \item parser \\
      RP, RPP(RevisedParserParser)
    \item printer \\
      OCaml
    \end{enumerate}
\item Camlp4rf (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      RP,RPP, GrammarP, ListComprehension, MacroP, QuotationExpander
    \item printer \\
      OCaml
    \end{enumerate}
\item Camlp4o (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      OP, OPP, RP,RPP
    \end{enumerate}
\item Camlp4of (extended from camlp4o)
    \begin{enumerate}
    \item parser \\
      GrammarParser, ListComprehension, MacroP, QuotatuinExpander
    \item printer 
    \end{enumerate}
\end{itemize}


\subsection{Simple Experiment}


Without \verb|ocamlbuild|, \verb|ocamlfind|, a simple build would be like this 

\begin{bashcode}
ocamlc -pp camlp4o.opt error.ml
\end{bashcode}  

\begin{bashcode}
camlp4of -str "let a = [x| x <- [1.. 10] ] "
\end{bashcode}

\begin{ocamlcode}
 let a = [ 1..10 ]
\end{ocamlcode}

\begin{bashcode}
 camlp4o -str 'true && false'
\end{bashcode}

\begin{ocamlcode}
true && false
\end{ocamlcode}


\begin{ocamlcode}
(** camlp4of -str "let q = <:str_item< let f x = x >>"*)
let q =
  Ast.StSem (_loc,
    (Ast.StVal (_loc, Ast.ReNil,
       (Ast.BiEq (_loc,
          (Ast.PaId (_loc, (Ast.IdLid (_loc, "f")))),
          (Ast.ExFun (_loc,
             (Ast.McArr
                (_loc,
                (Ast.PaId (_loc, (Ast.IdLid (_loc, "x")))),
                (Ast.ExNil _loc), (Ast.ExId (_loc, (Ast.IdLid (_loc, "x")))))))))))),
    (Ast.StNil _loc))
\end{ocamlcode}


\verb|camlp4of -p r -str 'you code'| is a good way to learn the
corresponding revised syntax.  You can also \textit{customize} you
options in your filter as sample code Listing \ref{lst:camlp4_options}
\subsubsection{Example Options Pa\_abstract}

\inputminted[fontsize=\scriptsize,
firstline=19,lastline=26]{ocaml}{camlp4/examples/pa_abstract.ml}
\captionof{listing}{Camlp4 Options \label{lst:camlp4_options}}


