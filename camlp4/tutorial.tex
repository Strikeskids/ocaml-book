\section{Basic Structure}


\subsection{Camlp4 Modules}
In the OCaml toplevel, you can load camlp4 via findlib as follows:

\begin{ocamlcode}
#camlp4r;
#load "camlp4rf.cma"
\end{ocamlcode}
Using \verb|ocamlobjinfo| to search modules [\ref{Camlp4 Modules}]:     


\begin{bashcode}
ocamlobjinfo `camlp4 -where`/camlp4fulllib.cma | grep -i unit
\end{bashcode}

\begin{bashcode}
 Camlp4_import Camlp4_config Camlp4 Camlp4AstLoader Camlp4DebugParser
 Camlp4GrammarParser Camlp4ListComprehension Camlp4MacroParser
 Camlp4OCamlParser Camlp4OCamlRevisedParser Camlp4QuotationCommon
 Camlp4OCamlOriginalQuotationExpander Camlp4OCamlRevisedParserParser
 Camlp4OCamlParserParser Camlp4OCamlRevisedQuotationExpander
 Camlp4QuotationExpander Camlp4AstDumper Camlp4AutoPrinter
 Camlp4NullDumper Camlp4OCamlAstDumper Camlp4OCamlPrinter
 Camlp4OCamlRevisedPrinter Camlp4AstLifter Camlp4ExceptionTracer
 Camlp4FoldGenerator Camlp4LocationStripper Camlp4MapGenerator
 Camlp4MetaGenerator Camlp4Profiler Camlp4TrashRemover Camlp4Top
\end{bashcode}
\captionof{listing}{Camlp4 Modules\label{Camlp4 Modules}}

You can build a simple script (oco [\ref{lst:oco}] with original
syntax, but when using ocr [\ref{lst:ocr} ] with revised syntax, it
will conflcit with \textit{-init} option, i.e. \textit{.ocamlinit},
and other startup files including findlib. Since when you load the
file, the syntax was already changed.

There's some work-around for ocr, but it still have some problem with
\textit{findlib}, which I think is internal, hard to solve, but it
does not really matter.


Another way to script the toplevel  is to \textit{customize your toplevel}.

\begin{bashcode}
bash-3.2$ cat /usr/local/bin/oco
ledit -x -h ~/.ocaml_history ocaml dynlink.cma camlp4of.cma -warn-error +a-4-6-27..29
\end{bashcode}
% $
\captionof{listing}{oco\label{lst:oco}}


\begin{bashcode}
bash-3.2$ cat `which ocr`
ledit -x -h ~/.ocaml_history ocaml dynlink.cma camlp4rf.cma -init ~/.ocamlinitr -warn-error +a-4-6-27..29
\end{bashcode}
% $
\captionof{listing}{ocr\label{lst:ocr}}

Customize toplevel(\ref{Customized toplevelr}) has some benefit, it
works seamlessly with \textit{Emacs caml-mode}.


\subsection{Revised Toplevel}
\begin{ocamlcode}
  ocamlfind mktop -custom -o oraml -I +camlp4 dynlink.cma camlp4rf.cma \
  str.cma bigarray.cma unix.cma nums.cma 
\end{ocamlcode}
\captionof{listing}{Customized toplevel with revised
  syntax \label{Customized toplevelr}}

Here \textit{-custom} option will try to link the \textit{c
  primitives} needed.

While you can link other useful libraries as below:

\begin{bashcode}
  ocamlfind mktop -custom -o temp -package unix -linkpkg
\end{bashcode}

You still have to supply the search path when you start.

\begin{bashcode}
#! /usr/bin/env bash
oraml -init ~/.or  
\end{bashcode}
\captionof{listing}{oramll \label{Oramll}}

You can specialize your revised toplevel here:

\inputminted[fontsize=\scriptsize]{ocaml}{homedir/.or}
\captionof{listing}{revised config file \label{or}}

\subsubsection{Try New Revised Toplevel}
\label{Try New Revised Toplevel}


Here are some experiments readers can have a try

\begin{ocamlcode}
# value cons = [``A'';''B'';''C''];
value cons : list string = [``A''; ``B''; ``C'']
# value tys = <:ctyp< [ $list: List.map (fun s -> <:ctyp< $uid:s$ >>)
cons $ ] >>;
value tys : Camlp4.PreCast.Ast.ctyp =
  TySum 
   (TyOr  (TyId  (IdUid  ``A''))
     (TyOr  (TyId  (IdUid  ``B'')) (TyId  (IdUid  ``C''))))
# value x  = <:ctyp< A | B | C >>;
value x : Camlp4.PreCast.Ast.ctyp =
  TyOr  (TyId  (IdUid  ``A''))
   (TyOr  (TyId  (IdUid  ``B'')) (TyId  (IdUid  ``C'')))
# value x  = <:ctyp< [ A | B | C ] >>;
value x : Camlp4.PreCast.Ast.ctyp =
  TySum 
   (TyOr  (TyOr  (TyId  (IdUid  ``A'')) (TyId  (IdUid  ``B'')))
   (TyId  (IdUid  ``C'')))
# <:str_item< type t = [A | B | C ] >> ;
- : Camlp4.PreCast.Ast.str_item =
StTyp 
 (TyDcl  ``t'' []
   (TySum 
     (TyOr  (TyOr  (TyId  (IdUid  ``A'')) (TyId  (IdUid  ``B'')))
       (TyId  (IdUid  ``C''))))
   [])
\end{ocamlcode}
\captionof{listing}{Playing with Simple \textit{ctyp} AST}


\begin{ocamlcode}
# value match_case = <:match_case< $list: List.map (fun c ->
<:match_case< $uid:c$ -> $`str:c$ >>) cons$ >>;
value match_case : Camlp4.PreCast.Ast.match_case =
  McOr  (McArr  (PaId  (IdUid  ``A'')) (ExNil ) (ExStr  ``A''))
   (McOr  (McArr  (PaId  (IdUid  ``B'')) (ExNil ) (ExStr  ``B''))
     (McArr  (PaId  (IdUid  ``C'')) (ExNil ) (ExStr  ``C'')))
# value to_string = <:expr< fun [ $match_case$ ] >> ;
value to_string : Camlp4.PreCast.Ast.expr =
  ExFun 
   (McOr  (McArr  (PaId  (IdUid  ``A'')) (ExNil ) (ExStr  ``A''))
     (McOr  (McArr  (PaId  (IdUid  ``B'')) (ExNil ) (ExStr  ``B''))
       (McArr  (PaId  (IdUid  ``C'')) (ExNil ) (ExStr  ``C''))))
\end{ocamlcode}
\captionof{listing}{Play with pattern AST}

\begin{ocamlcode}
# opr#match_case std_formatter match_case;
 [ A -> ``A'' | B -> ``B''
 | C -> ``C'' ]- : unit = ()
# opr#expr std_formatter to_string;
fun [ A -> ``A'' | B -> ``B'' | C -> ``C'' ]- : unit = ()
\end{ocamlcode}
\captionof{listing}{Play with printer}


  
\subsection{Command Options}

\begin{bashcode}
bash-3.2$ camlp4 -where
/Users/bob/SourceCode/ML/godi/lib/ocaml/std-lib/camlp4
bash-3.2$ which camlp4
/Users/bob/SourceCode/ML/godi/bin/camlp4
\end{bashcode}


You can grep all executables [\ref{List of camlp4 exectuables}]
relevant to camlp4 using a one-line bash as follows:

\begin{bashcode}
find $(dirname $(which ocaml)) -type f -perm -og+rx | grep camlp4 |
while read ss ; do echo $(basename $ss) ; done
\end{bashcode}

\begin{bashcode}  
camlp4 camlp4boot camlp4o camlp4o.opt camlp4of camlp4of.opt camlp4oof
camlp4oof.opt camlp4orf camlp4orf.opt camlp4prof camlp4r camlp4r.opt
camlp4rf camlp4rf.opt mkcamlp4 safe_camlp4
\end{bashcode}
\captionof{listing}{List of camlp4 executables \label{List of camlp4 executables}}

So the tools at hand include \textit{camlp4, camlp4o, camlp4of,
  camlp4oof, camlp4orf, camlp4r, camlp4rf }

You can type \textit{camlp4 -h } to enumerate all the command line
options. Some pretty useful options are: 

\verb|-str|

\verb|-loaded-modules|

\verb|-parser <name>| load the parser \textit{Camlp4Parsers/<name>.cm(o|a|xs)}


\verb|-printer <name>| load the printer
\textit{Camlp4Printerss/<name>.cm(o|a|xs)}

\verb|-filter <name>| load the filter 
\textit{Camlp4Filters/<name>.cm(o|a|xs).}


\verb|-printer o| means print in original syntax. 


These command line options are all handled in \emph{Camlp4Bin.ml}

\verb|Camlp4o -h| There are options added by loaded object files. You
can added by \verb|Options.add| as well.


\verb| -add_locations| Add locations as comment. You need to turn off
\textit{-printer} options before taking it. It provides detailed
parsing locations for debugging purpose.


\verb| -no_comments|


\verb| -curry-constr |


\verb| -sep | Use this string between parsers 




\subsection{Module Components}

\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
                      & host     & embedded & reflective & 3.09 equivalent     \\
    camlp4of          & original & original & Yes        & N/A                 \\
    camlp4rf          & revised  & revised  & Yes        & N/A                 \\
    camlp4r-parser rq & revised  & revised  & No         & camlp4r q\_MLast.cmo \\
    camlp4orf         & original & revised  & No         & camlp4o q\_MLast.cmo \\
    camlp4oof         & original & original & No         & N/A                 \\
    \hline
  \end{tabular}
  \caption{Module Components}
  \label{tab:camlp4_module_components}
\end{table}

Table \ref{tab:camlp4_module_components} list all components in camlp4
modules. That reflective is true means when extending the syntax of the
host language will \textbf{ also extend the embedded one}

\begin{itemize}  
\item Camlp4r
    \begin{enumerate}
    \item parser \\
      RP, RPP(RevisedParserParser)
    \item printer \\
      OCaml
    \end{enumerate}
\item Camlp4rf (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      RP,RPP, GrammarP, ListComprehension, MacroP, QuotationExpander
    \item printer \\
      OCaml
    \end{enumerate}
\item Camlp4o (extended from camlp4r)
    \begin{enumerate}
    \item parser \\
      OP, OPP, RP,RPP
    \end{enumerate}
\item Camlp4of (extended from camlp4o)
    \begin{enumerate}
    \item parser \\
      GrammarParser, ListComprehension, MacroP, QuotatuinExpander
    \item printer 
    \end{enumerate}
\end{itemize}


\subsection{Simple Building Experiment}

Without \verb|ocamlbuild|, \verb|ocamlfind|, a simple build would be
like this

\begin{bashcode}
ocamlc -pp camlp4o.opt error.ml
\end{bashcode}  

This way is not recommended to play with \textit{camlp4}, rolling a
robust \textit{myocamlbuild}(\ref{myocamlbuild}) is the right way to
use camlp4, otherwise you may be frustrated with the complex building
process.

