\section{Ast Transformation}
\label{transform}

The filter \emph{Camlp4MapGenerator} reads \emph{OCaml} type
definitions and generate a class that implements a map traversal.  The
generated class have a method per type you can override to implement a
\emph{map traversal}.

Camlp4 uses the \textbf{ filter} iteself to bootstrap.


\begin{bluecode}
(** file Camlp4Ast.mlast *)
class map = Camlp4MapGenerator.generated;
class fold = Camlp4FoldGenerator.generated;
\end{bluecode}

As above, \verb|Camlp4.Ast| has a corresponding map traversal object,
which could be used by you: (the class was generated by our filter)
\verb|Ast.map| is a class
\begin{bluecode}
let b = new Camlp4.PreCast.Ast.map ;;
val b : Camlp4.PreCast.Ast.map = <obj>
\end{bluecode}

\inputminted[firstline=1,lastline=9]{ocaml}{camlp4/code/ast_add_zero.ml}
you can write it without sytax extension(very tedious),
\inputminted[firstline=11,lastline=31]{ocaml}{camlp4/code/ast_add_zero.ml}
To make life easier, you can write like this 
\inputminted[firstline=32,lastline=38]{ocaml}{camlp4/code/ast_add_zero.ml}

In the module \verb|Camlp4.PreCast.AstFilters|, there are some
utiliies to do filter over the ast.
\begin{bluecode}
    type 'a filter = 'a -> 'a
    val register_sig_item_filter : Ast.sig_item filter -> unit
    val register_str_item_filter : Ast.str_item filter -> unit
    val register_topphrase_filter : Ast.str_item filter -> unit
    val fold_interf_filters : ('a -> Ast.sig_item filter -> 'a) -> 'a -> 'a
    val fold_implem_filters : ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
    val fold_topphrase_filters :
      ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
\end{bluecode}


You can also generate map traversal for ocaml type. \emph{put your
  type definition before} you macro, like this
\inputminted{ocaml}{camlp4/code/ast_map.ml}
Without filter, you would write the transformer by hand like this 
\inputminted{ocaml}{camlp4/code/ast_map_o.ml}


Camlp4 use the filter in \verb|antiquot_expander|, for example in
\textit{Camlp4Parsers/Camlp4QuotationCommon.ml}, in the definition of
\verb|add_quotation|, we have


\begin{bluecode}
value antiquot_expander = object
  inherit Ast.map as super ;
  method patt : patt -> patt ...
  method expr : expr -> expr ...
let expand_expr loc loc_name_opt s =
  let ast = parse_quot_string entry_eoi loc s in
  let _ = MetaLoc.loc_name.val := loc_name_opt in
  let meta_ast = mexpr loc ast in
  let exp_ast = antiquot_expander#expr meta_ast in
  exp_ast in
\end{bluecode}


Notice that it first invoked \verb|parse_quot_string|, then do some
transformation, \textbf{ that's how quotation works} !, it will be
changed to your customized quotation parser, and when it goes to
antiquot syntax, it will go back to \textbf{ host language
  parser}. Since the host language parser also support quotation
syntax (due to \textbf{ reflexivity}), so you \textbf{ nest your
  quotation whatever you want.}

