\section{Camlp4 SourceCode Exploration}
Now we begin to explore the structure of camlp4 Source Code.  First
let's have a look at the directory structure of \verb|camlp4|
directory.


\begin{bashcode}
.
|-- boot
|-- build
|-- Camlp4
|   |-- Printers
|   `-- Struct      
|       `-- Grammar
|-- Camlp4Filters
|-- Camlp4Parsers
|-- Camlp4Printers
|-- Camlp4Top
|-- examples
|-- man
|-- test
|   `-- fixtures
`-- unmaintained   
\end{bashcode}

\subsection{Camlp4.Sig}
For \verb|Camlp4.Sig.ml|, all are signatures. It's convention for
ocaml programmers to document most signatures in \textit{Sig.ml}.

\subsubsection{Basic Signature}

\begin{ocamlcode}
module type Type = sig
  type t;
end;
\end{ocamlcode}
\captionof{listing}{Signature with a type}

\begin{ocamlcode}
module type Error = sig
  type t;
  exception E of t;
  value to_string : t -> string;
  value print : Format.formatter -> t -> unit;
end;
\end{ocamlcode}
\captionof{listing}{Error module type}

Signature for errors modules, an \textit{Error} module can be
registred with the \textit{ErrorHandler.Register} functor in order to
be well printed.

\begin{ocamlcode}
module Warning (Loc : Type) = struct
  module type S = sig
    type warning = Loc.t -> string -> unit;
    value default_warning : warning;
    value current_warning : ref warning;
    value print_warning   : warning;
  end;
end;
\end{ocamlcode}
\captionof{listing}{Warning Functor}
It's interesting here \textit{Warning} is a type level function
actually. Making it a function so you can use \textit{Warning(Loc).S}
later.

\subsubsection{Advanced Signatures}

\begin{description}
\item[Loc] A signature for locations
\item[Ast] Ast \textit{minimal, abstract} signature
\item[Camlp4Ast] Ast \textit{concrete} signature
\item[Camlp4AstToAst]
  \textit{functor (M:Camp4Ast) : Ast with  type .. = ...}. This
  functor is a restriction functor. You can use it like this
  \textit{with module Ast = Camlp4.Sig.Camlp4AstToAst Camlp4Ast}

\item[MakeCamlp4Ast] the only concrete definition of camlp4 ast. You
  can write some generic plugins here.
\item[AstFilters] Registering and folding of Ast filters, it includes
  \textit{Camlp4Ast} and some filter functions

\item[DynAst] Asts as one single dynamic type

\item[Quotation] signature for a quoation expander registery
\item[Token] A signature around tokens.
\item[Camlp4Token] \textit{Token with type t = camlp4\_token}
\item[DynLoader]
\item[Grammar]
\item[Lexer]
\item[Parser] Parser is a type lever function, like \textit{Warning}
\item[Printer] The same as above

\item[Syntax] A syntax module is a sort of constistent bunch of
  modules and values.  In such a module you have a parser, a printer,
  and also modules for locations, syntax trees, tokens, grammars,
  quotations, anti-quotations.  There is also the main grammar
  entries.
\item[Camlp4Syntax] Ast is replaced with Camlp4Ast
\item[SyntaxExtension] functor signature.

  \begin{ocamlcode}
module type SyntaxExtension = functor (Syn : Syntax)
                    -> (Syntax with module Loc            = Syn.Loc
                                and module Ast            = Syn.Ast
                                and module Token          = Syn.Token
                                and module Gram           = Syn.Gram
                                and module Quotation      = Syn.Quotation);
    
  \end{ocamlcode}
\end{description}
We can make use of these signatures to write signature file.
\textit{Ast} is an


\subsection{Camlp4.PreCast}
As above,\textit{Struct}
directory has module \textit{Loc, Dynloader
  Functor, Camlp4Ast.Make, Token.Make, Lexer.Make,
  Grammar.Static.Make, Quotation.Make}

File \verb|Camlp4.PreCast| Listing \ref{lst:Camlp4 PreCast}
packed such modules

\begin{bluetext}
  Struct.Loc Struct.Camlp4Ast Struct.Token Struct.Grammar.Parser
  Struct.Grammar.Static Struct.Lexer Struct.DynLoader Struct.Quotation
  Struct.AstFilters OCamlInitSyntax Printers.OCaml Printers.OCamlr
  Printers.Null Printers.DumpCamlp4Ast Printers.DumpOCamlAst
\end{bluetext}


\inputminted[fontsize=\scriptsize, 
lastline=55]{ocaml}{code/camlp4/source/precast.ml}
\captionof{listing}{Camlp4 PreCast \label{lst:Camp4 PreCast}}



\subsection{Camlp4.OCamlInitSyntax}

\verb|OCamlInitSyntax| Listing \ref{lst:OCamlInitSyntax} does not do
too many things, first, it initialize all the entries needed later
(they are all blank, to be extended by your functor), after
initialization, it created a submodule \verb|AntiquotSyntax|, and
initialize two entries \verb|antiquot_expr| and \verb|antiquot_patt|,
very easy.

Its signature is as follows:
\begin{ocamlcode}
module Make (Ast     : Sig.Camlp4Ast)
            (Gram    : Sig.Grammar.Static with module Loc = Ast.Loc
                        with type Token.t = Sig.camlp4_token)
           (Quotation : Sig.Quotation with
                        module Ast = Sig.Camlp4AstToAst Ast)
: Sig.Camlp4Syntax with module Loc = Ast.Loc
                    and module Ast = Ast
                    and module Token = Gram.Token
                    and module Gram = Gram
                    and module Quotation = Quotation  
\end{ocamlcode}
                  
\inputminted[fontsize=\scriptsize,
firstline=55]{ocaml}{code/camlp4/source/precast.ml}
\captionof{listing}{OCamlInitSyntax \label{lst:OCamlInitSyntax}}



\subsection{Camlp4.Struct.Camlp4Ast.mlast} 

This file use macro\verb|INCLUDE| to include
\verb|Camlp4.Camlp4Ast.parital.ml| for reuse.


\subsection{Camlp4.Register.AstFilter}    
Notice an interesting module \verb|AstFilter| Listing
\ref{lst:AstFilters}, is defined by \verb|Struct.AstFilters.Make|,
which we see in \verb|Camlp4.PreCast.ml|\ref{lst:Camlp4 PreCast} It's
very simple actually.

\begin{ocamlcode}
module AstFilter
  (Id : Sig.Id) (Maker : functor (F : Sig.AstFilters) -> sig end) =
struct
  declare_dyn_module Id.name (fun _ -> let module M = Maker AstFilters in ());
\end{ocamlcode}

\inputminted[fontsize=\scriptsize,]{ocaml}{code/camlp4/source/AstFilters.ml}
\captionof{listing}{AstFilters \label{lst:AstFilters}}



\begin{ocamlcode}
(** file Camlp4Ast.mlast   in the file we have *)
Camlp4.Struct.Camlp4Ast.Make : Loc -> Sig.Camlp4Syntax
  module Ast = struct
     include Sig.MakeCamlp4Ast Loc 
  end ;
\end{ocamlcode}
\captionof{listing}{Camlp4Ast Make\label{lst:Camlp4Ast Make}}

\subsection{Camlp4.Struct.Grammar}
\label{Camlp4.Struct.Grammar}

In this directory, it defines mainly the syntax level engine.
First let's take a look at \textit{Camlp4.Sig.Grammar}.
It has type definitions for \textit{assoc, position}, and
four \textit{module type: Action, Structure, Dynamic,Static}.

In file \textit{Camlp4.Struct.Grammar.Structure}, it defines a
\textit{module type S}, which includes \textit{type gram,
  token\_info,} \textit{token\_stream,internal\_entry}, \textit{desc,level and symbol,
}, Then it defines a functor \textit{Make} which is given a
\textit{Lexer} and implements \textit{module type S}

\subsubsection{Camlp4.Struct.Grammar.Print}
\label{Camlp4.Struct.Grammar.Print}
This file only depends \textit{Structure.S} It implements a lot of
interesting stuff for debugging the dynamic parser

\subsubsection{Camlp4.Struct.Grammar.Tools}
For this module, it defines some parsing utility functions.

\subsubsection{Camlp4.Struct.Grammar.Parser}
\label{Camlp4.Struct.Grammar.Parser}


\subsection{Camlp4.Register}
Let's see what's in \verb|Register| Listing \ref{lst:Camlp4
  Register}module


\inputminted[fontsize=\scriptsize,
]{ocaml}{code/camlp4/source/Register.ml}
\captionof{listing}{Camlp4 Register\label{lst:Camlp4 Register}}

Notice that functors Plugin, SyntaxExtension, OCamlSyntaxExtension,
OCamlSyntaxExtension, SyntaxPlugin, they did the same thing
essentially, they apply the second Funtor to
Syntax(Camlp4.PreCast.Syntax).

Functors Printer, OCamlPrinter, OCamlPrinter, they did the same thing,
apply the Make to Syntax, then register it. 

Functors Parser, OCamlParser, did the same thing. 

Functors AstFilter  did nothing interesting.

It sticks to the toplevel Listing

\inputminted[fontsize=\scriptsize, firstline=123, lastline=126,
]{ocaml}{code/camp4/source/Register.ml}
\captionof{listing}{Camlp4 Register Part 2 \label{lst:Camlp4 Register
    Part 2}}

It mainly hook some global variables, like
\verb|Camlp4.Register.loaded_modlules|, but there's no fresh meat in
this file.  To conclude, Register did nothing, except making your code
more modular, or register your syntax extension.

As we said, another utility, you can inspect what modules you have
loaded in toplevel:

\begin{ocamlcode}
Camlp4.Register.loaded_modules;;
- : string list ref =
{Pervasives.contents =
  ["Camlp4GrammarParser"; "Camlp4OCamlParserParser";
   "Camlp4OCamlRevisedParserParser"; "Camlp4OCamlParser";
   "Camlp4OCamlRevisedParser"]}
\end{ocamlcode}


\section{Camlp4Ast}

As the code Listing \ref{lst:Camlp4 Ast Definition} demonstrate below,
there are several categories including \textit{ident, ctyp,patt,expr,
  module\_type, sig\_item, with\_constr, binding, rec\_binding,
  module\_binding, match\_case, module\_expr,str\_item, class\_type,
  class\_sig\_item, class\_expr, class\_str\_item,}. And there are
antiquotations for each syntax category, i.e,
\textit{IdAnt,TyAnt,PaAnt,ExAnt,MtAnt, SgAnt, WcAnt, BiAnt,
  RbAnt,MbAnt,McAnt,MeAnt,StAnt,CtAnt,CgAnt, CeAnt, CrAnt}


\inputminted[fontsize=\scriptsize,
]{ocaml}{camlp4/code/ast/ast_def.ml}
\captionof{listing}{Camlp4 Ast Definition\label{lst:Camlp4 Ast Definition}}


\section{TestFile}
\label{sec:testfile}
Some test files are pretty useful(in the distribution of camlp4)
like \verb|test/fixtures/macro_test.ml|.
